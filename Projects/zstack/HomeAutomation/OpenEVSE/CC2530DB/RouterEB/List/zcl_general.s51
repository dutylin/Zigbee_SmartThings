///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V9.30.3.3983 for 8051               09/Dec/2016  16:08:03
// Copyright 2004-2016 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Users\Admin\Desktop\zigbee with
//        smartThings\Components\stack\zcl\zcl_general.c
//    Command line       =  
//        -f "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DRTR_NWK) -f "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x07FFF800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
//        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
//        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000)
//        -f "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Components\stack\zcl\zcl_general.c" -D SECURE=1 -D
//        TC_LINKKEY_JOIN -D HAL_UART=TRUE -D HAL_UART_DMA_RX_MAX=64 -D
//        HAL_PA_LNA_CC2592 -D NV_INIT -D NV_RESTORE -D MULTICAST_ENABLED=FALSE
//        -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D ZCL_BASIC -D ZCL_ON_OFF -D
//        ZCL_ELECTRICAL_MEASUREMENT -lC "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List"
//        -lA "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -I
//        "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\" -I
//        "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\Source\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\Source\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes
//    List file          =  
//        C:\Users\Admin\Desktop\zigbee with
//        smartThings\Projects\zstack\HomeAutomation\OpenEVSE\CC2530DB\RouterEB\List\zcl_general.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_general

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V2
        EXTERN ?V3
        EXTERN ?V1
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?US_SWITCH_SPARSE
        EXTERN __INIT_XDATA_Z

        FUNCTION `??zclGeneral_HdlInSpecificCommands::?relay`,0203H
        FUNCTION `??zclGeneral_HdlIncoming::?relay`,0203H
        PUBLIC `??zclGeneral_RegisterCmdCallbacks::?relay`
        FUNCTION `??zclGeneral_RegisterCmdCallbacks::?relay`,0203H
        FUNCTION zclGeneral_HdlInSpecificCommands,080203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION zclGeneral_HdlIncoming,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 14, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
osal_mem_alloc      SYMBOL "osal_mem_alloc"
`??osal_mem_alloc::?relay` SYMBOL "?relay", osal_mem_alloc
zcl_registerPlugin  SYMBOL "zcl_registerPlugin"
`??zcl_registerPlugin::?relay` SYMBOL "?relay", zcl_registerPlugin
zclGeneral_RegisterCmdCallbacks SYMBOL "zclGeneral_RegisterCmdCallbacks"
`??zclGeneral_RegisterCmdCallbacks::?relay` SYMBOL "?relay", zclGeneral_RegisterCmdCallbacks

        EXTERN `??osal_mem_alloc::?relay`
        FUNCTION `??osal_mem_alloc::?relay`,00H
        EXTERN `??zcl_registerPlugin::?relay`
        FUNCTION `??zcl_registerPlugin::?relay`,00H
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN zcl_registerPlugin
        FUNCTION zcl_registerPlugin,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// C:\Users\Admin\Desktop\zigbee with smartThings\Components\stack\zcl\zcl_general.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_general.c
//    3   Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
//    4   Revision:       $Revision: 44493 $
//    5 
//    6   Description:    Zigbee Cluster Library - General.  This application receives all
//    7                   ZCL messages and initially parses them before passing to application.
//    8 
//    9 
//   10   Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   IMPORTANT: Your use of this Software is limited to those specific rights
//   13   granted under the terms of a software license agreement between the user
//   14   who downloaded the software, his/her employer (which must be your employer)
//   15   and Texas Instruments Incorporated (the "License"). You may not use this
//   16   Software unless you agree to abide by the terms of the License. The License
//   17   limits your use, and you acknowledge, that the Software may not be modified,
//   18   copied or distributed unless embedded on a Texas Instruments microcontroller
//   19   or used solely and exclusively in conjunction with a Texas Instruments radio
//   20   frequency transceiver, which is integrated into your product. Other than for
//   21   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   22   works of, modify, distribute, perform, display or sell this Software and/or
//   23   its documentation for any purpose.
//   24 
//   25   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   26   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   27   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   28   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   29   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   30   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   31   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   32   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   33   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   34   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   35   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   36 
//   37   Should you have any questions regarding your right to use this Software,
//   38   contact Texas Instruments Incorporated at www.TI.com.
//   39 **************************************************************************************************/
//   40 
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "ZComDef.h"
//   45 #include "zcl.h"
//   46 #include "hal_led.h"
//   47 #include "zcl_general.h"
//   48 //#include "ZDApp.h"
//   49 #include "zcl_ezmode.h"
//   50 
//   51 #if defined ( INTER_PAN )
//   52   #include "stub_aps.h"
//   53 #endif
//   54 
//   55 /*********************************************************************
//   56  * MACROS
//   57  */
//   58 #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
//   59 #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
//   60 #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
//   61 
//   62 #ifdef ZCL_SCENES
//   63 #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
//   64 #endif // ZCL_SCENES
//   65 
//   66 /*********************************************************************
//   67  * CONSTANTS
//   68  */
//   69 
//   70 /*********************************************************************
//   71  * TYPEDEFS
//   72  */
//   73 typedef struct zclGenCBRec
//   74 {
//   75   struct zclGenCBRec        *next;
//   76   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   77   zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
//   78 } zclGenCBRec_t;
//   79 
//   80 typedef struct zclGenSceneItem
//   81 {
//   82   struct zclGenSceneItem    *next;
//   83   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   84   zclGeneral_Scene_t        scene;    // Scene info
//   85 } zclGenSceneItem_t;
//   86 
//   87 typedef struct zclGenAlarmItem
//   88 {
//   89   struct zclGenAlarmItem    *next;
//   90   uint8                     endpoint; // Used to link it into the endpoint descriptor
//   91   zclGeneral_Alarm_t        alarm;    // Alarm info
//   92 } zclGenAlarmItem_t;
//   93 
//   94 // Scene NV types
//   95 typedef struct
//   96 {
//   97   uint16                    numRecs;
//   98 } nvGenScenesHdr_t;
//   99 
//  100 typedef struct zclGenSceneNVItem
//  101 {
//  102   uint8                     endpoint;
//  103   zclGeneral_Scene_t        scene;
//  104 } zclGenSceneNVItem_t;
//  105 
//  106 /*********************************************************************
//  107  * GLOBAL VARIABLES
//  108  */
//  109 
//  110 /*********************************************************************
//  111  * GLOBAL FUNCTIONS
//  112  */
//  113 
//  114 /*********************************************************************
//  115  * LOCAL VARIABLES
//  116  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  117 static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
zclGenCBs:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  118 static uint8 zclGenPluginRegisted = FALSE;
zclGenPluginRegisted:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  119 
//  120 #if defined( ZCL_SCENES )
//  121   #if !defined ( ZCL_STANDALONE )
//  122     static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
//  123   #endif
//  124 #endif // ZCL_SCENES
//  125 
//  126 #ifdef ZCL_ALARMS
//  127 static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
//  128 #endif // ZCL_ALARMS
//  129 
//  130 /*********************************************************************
//  131  * LOCAL FUNCTIONS
//  132  */
//  133 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
//  134 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  135 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
//  136 
//  137 // Device Configuration and Installation clusters
//  138 #ifdef ZCL_BASIC
//  139 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  140 #endif // ZCL_BASIC
//  141 
//  142 #ifdef ZCL_IDENTIFY
//  143 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  144 #endif // ZCL_IDENTIFY
//  145 
//  146 // Groups and Scenes clusters
//  147 #ifdef ZCL_GROUPS
//  148 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
//  149 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  150 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
//  151 #endif // ZCL_GROUPS
//  152 
//  153 #ifdef ZCL_SCENES
//  154 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  155 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  156 #endif // ZCL_SCENES
//  157 
//  158 // On/Off and Level Control Configuration clusters
//  159 #ifdef ZCL_ON_OFF
//  160 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  161 #endif // ZCL_ONOFF
//  162 
//  163 #ifdef ZCL_LEVEL_CTRL
//  164 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  165 #endif // ZCL_LEVEL_CTRL
//  166 
//  167 // Alarms cluster
//  168 #ifdef ZCL_ALARMS
//  169 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  170 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  171 #endif // ZCL_ALARMS
//  172 
//  173 // Location cluster
//  174 #ifdef ZCL_LOCATION
//  175 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  176 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
//  177 #endif // ZCL_LOCATION
//  178 
//  179 #ifdef ZCL_SCENES
//  180   #if !defined ( ZCL_STANDALONE )
//  181     static uint8 zclGeneral_ScenesInitNV( void );
//  182     static void zclGeneral_ScenesSetDefaultNV( void );
//  183     static void zclGeneral_ScenesWriteNV( void );
//  184     static uint16 zclGeneral_ScenesRestoreFromNV( void );
//  185   #endif
//  186 #endif // ZCL_SCENES
//  187 
//  188 /*********************************************************************
//  189  * @fn      zclGeneral_RegisterCmdCallbacks
//  190  *
//  191  * @brief   Register an applications command callbacks
//  192  *
//  193  * @param   endpoint - application's endpoint
//  194  * @param   callbacks - pointer to the callback record.
//  195  *
//  196  * @return  ZMemError if not able to allocate
//  197  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
//  198 ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
zclGeneral_RegisterCmdCallbacks:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function zclGeneral_RegisterCmdCallbacks
        CODE
//  199 {
        FUNCALL zclGeneral_RegisterCmdCallbacks, zcl_registerPlugin
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL zclGeneral_RegisterCmdCallbacks, osal_mem_alloc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V2
        REQUIRE ?V3
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0,R1
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  200   zclGenCBRec_t *pNewItem;
//  201   zclGenCBRec_t *pLoop;
//  202 
//  203   // Register as a ZCL Plugin
//  204   if ( zclGenPluginRegisted == FALSE )
        MOV     DPTR,#zclGenPluginRegisted
        MOVX    A,@DPTR
        JNZ     ??zclGeneral_RegisterCmdCallbacks_0
//  205   {
//  206     zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
//  207                         ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
//  208                         zclGeneral_HdlIncoming );
        ; Setup parameters for call to function zcl_registerPlugin
        MOV     ?V2,#`??zclGeneral_HdlIncoming::?relay` & 0xff
        MOV     ?V3,#(`??zclGeneral_HdlIncoming::?relay` >> 8) & 0xff
        MOV     R0,#?V2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#0x14
        MOV     R5,#0x0
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   `??zcl_registerPlugin::?relay`; Banked call to: zcl_registerPlugin
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
//  209 
//  210 #ifdef ZCL_SCENES
//  211     // Initialize the Scenes Table
//  212     zclGeneral_ScenesInit();
//  213 #endif // ZCL_SCENES
//  214 
//  215     zclGenPluginRegisted = TRUE;
        MOV     DPTR,#zclGenPluginRegisted
        MOV     A,#0x1
        MOVX    @DPTR,A
//  216   }
//  217 
//  218   // Fill in the new profile list
//  219   pNewItem = zcl_mem_alloc( sizeof( zclGenCBRec_t ) );
??zclGeneral_RegisterCmdCallbacks_0:
        ; Setup parameters for call to function osal_mem_alloc
        MOV     R2,#0x5
        MOV     R3,#0x0
        LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
        MOV     ?V2,R2
        MOV     ?V3,R3
        MOV     R0,?V2
        MOV     R1,?V3
//  220   if ( pNewItem == NULL )
        MOV     A,R0
        ORL     A,R1
        JNZ     ??zclGeneral_RegisterCmdCallbacks_1
//  221     return (ZMemError);
        MOV     R1,#0x10
        SJMP    ??zclGeneral_RegisterCmdCallbacks_2
//  222 
//  223   pNewItem->next = (zclGenCBRec_t *)NULL;
??zclGeneral_RegisterCmdCallbacks_1:
        MOV     DPL,R0
        MOV     DPH,R1
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  224   pNewItem->endpoint = endpoint;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOV     A,?V0
        MOVX    @DPTR,A
//  225   pNewItem->CBs = callbacks;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
//  226 
//  227   // Find spot in list
//  228   if (  zclGenCBs == NULL )
        MOV     DPTR,#zclGenCBs
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        MOV     DPTR,#zclGenCBs
        JZ      ??zclGeneral_RegisterCmdCallbacks_3
//  229   {
//  230     zclGenCBs = pNewItem;
//  231   }
//  232   else
//  233   {
//  234     // Look for end of list
//  235     pLoop = zclGenCBs;
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        SJMP    ??zclGeneral_RegisterCmdCallbacks_4
//  236     while ( pLoop->next != NULL )
//  237       pLoop = pLoop->next;
??zclGeneral_RegisterCmdCallbacks_5:
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
??zclGeneral_RegisterCmdCallbacks_4:
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        ORL     A,R3
        JNZ     ??zclGeneral_RegisterCmdCallbacks_5
//  238 
//  239     // Put new item at end of list
//  240     pLoop->next = pNewItem;
        MOV     DPL,R4
        MOV     DPH,R5
??zclGeneral_RegisterCmdCallbacks_3:
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  241   }
//  242 
//  243   return ( ZSuccess );
        MOV     R1,#0x0
??zclGeneral_RegisterCmdCallbacks_2:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
//  244 }
          CFI EndBlock cfiBlock0
//  245 
//  246 #ifdef ZCL_IDENTIFY
//  247 /*********************************************************************
//  248  * @fn      zclGeneral_SendIdentify
//  249  *
//  250  * @brief   Call to send out an Identify Command
//  251  *
//  252  * @param   srcEP - Sending application's endpoint
//  253  * @param   dstAddr - where you want the message to go
//  254  * @param   identifyTime - how long the device will continue to identify itself (in seconds)
//  255  * @param   seqNum - identification number for the transaction
//  256  *
//  257  * @return  ZStatus_t
//  258  */
//  259 ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
//  260                                    uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
//  261 {
//  262   uint8 buf[2];
//  263 
//  264   buf[0] = LO_UINT16( identifyTime );
//  265   buf[1] = HI_UINT16( identifyTime );
//  266 
//  267   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  268                           COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  269                           disableDefaultRsp, 0, seqNum, 2, buf );
//  270 }
//  271 
//  272 /*********************************************************************
//  273  * @fn      zclGeneral_SendIdentifyEZModeInvoke
//  274  *
//  275  * @brief   Call to send out an Identify EZ-Mode Invoke Command
//  276  *
//  277  * @param   srcEP - Sending application's endpoint
//  278  * @param   dstAddr - where you want the message to go
//  279  * @param   action - describes the EZ-Mode action to be performed
//  280  * @param   seqNum - identification number for the transaction
//  281  *
//  282  * @return  ZStatus_t
//  283  */
//  284 ZStatus_t zclGeneral_SendIdentifyEZModeInvoke( uint8 srcEP, afAddrType_t *dstAddr,
//  285                                                uint8 action, uint8 disableDefaultRsp, uint8 seqNum )
//  286 {
//  287   uint8 buf[1];
//  288 
//  289   buf[0] = action;
//  290 
//  291   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  292                           COMMAND_IDENTIFY_EZMODE_INVOKE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  293                           disableDefaultRsp, 0, seqNum, 1, buf );
//  294 }
//  295 
//  296 /*********************************************************************
//  297  * @fn      zclGeneral_SendIdentifyUpdateCommState
//  298  *
//  299  * @brief   Call to send out an Identify Update Commission State Command
//  300  *
//  301  * @param   srcEP - Sending application's endpoint
//  302  * @param   dstAddr - where you want the message to go
//  303  * @param   action - describes the EZ-Mode action to be performed
//  304  * @param   commissionStateMask - updates the device's commission state
//  305  * @param   seqNum - identification number for the transaction
//  306  *
//  307  * @return  ZStatus_t
//  308  */
//  309 ZStatus_t zclGeneral_SendIdentifyUpdateCommState( uint8 srcEP, afAddrType_t *dstAddr,
//  310                                                   uint8 action, uint8 commissionStateMask,
//  311                                                   uint8 disableDefaultRsp, uint8 seqNum )
//  312 {
//  313   uint8 buf[2];
//  314 
//  315   buf[0] = action;
//  316   buf[1] = commissionStateMask;
//  317 
//  318   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  319                           COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  320                           disableDefaultRsp, 0, seqNum, 2, buf );
//  321 }
//  322 
//  323 #ifdef ZCL_LIGHT_LINK_ENHANCE
//  324 /*********************************************************************
//  325  * @fn      zclGeneral_SendIdentifyTriggerEffect
//  326  *
//  327  * @brief   Call to send out a Trigger Effect Command
//  328  *
//  329  * @param   srcEP - Sending application's endpoint
//  330  * @param   dstAddr - where you want the message to go
//  331  * @param   effectId - identify effect to use
//  332  * @param   effectVariant - which variant of effect to be triggered
//  333  * @param   disableDefaultRsp - whether to disable the Default Response command
//  334  * @param   seqNum - identification number for the transaction
//  335  *
//  336  * @return  ZStatus_t
//  337  */
//  338 ZStatus_t zclGeneral_SendIdentifyTriggerEffect( uint8 srcEP, afAddrType_t *dstAddr,
//  339                                                 uint8 effectId, uint8 effectVariant,
//  340                                                 uint8 disableDefaultRsp, uint8 seqNum )
//  341 {
//  342   uint8 buf[2];
//  343 
//  344   buf[0] = effectId;
//  345   buf[1] = effectVariant;
//  346 
//  347   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  348                           COMMAND_IDENTIFY_TRIGGER_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  349                           disableDefaultRsp, 0, seqNum, 2, buf );
//  350 }
//  351 #endif // ZCL_LIGHT_LINK_ENHANCE
//  352 
//  353 /*********************************************************************
//  354  * @fn      zclGeneral_SendIdentifyQueryResponse
//  355  *
//  356  * @brief   Call to send out an Identify Query Response Command
//  357  *
//  358  * @param   srcEP - Sending application's endpoint
//  359  * @param   dstAddr - where you want the message to go
//  360  * @param   timeout - how long the device will continue to identify itself (in seconds)
//  361  * @param   seqNum - identification number for the transaction
//  362  *
//  363  * @return  ZStatus_t
//  364  */
//  365 ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  366                                                 uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
//  367 {
//  368   uint8 buf[2];
//  369 
//  370   buf[0] = LO_UINT16( timeout );
//  371   buf[1] = HI_UINT16( timeout );
//  372 
//  373   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
//  374                           COMMAND_IDENTIFY_QUERY_RSP, TRUE,
//  375                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
//  376 }
//  377 #endif // ZCL_IDENTIFY
//  378 
//  379 #ifdef ZCL_GROUPS
//  380 /*********************************************************************
//  381  * @fn      zclGeneral_SendGroupRequest
//  382  *
//  383  * @brief   Send a Group Request to a device.  You can also use the
//  384  *          appropriate macro.
//  385  *
//  386  * @param   srcEP - Sending Apps endpoint
//  387  * @param   dstAddr - where to send the request
//  388  * @param   cmd - one of the following:
//  389  *              COMMAND_GROUP_VIEW
//  390  *              COMMAND_GROUP_REMOVE
//  391  * @param   groupID -
//  392  *
//  393  * @return  ZStatus_t
//  394  */
//  395 ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  396                                        uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  397 {
//  398   uint8 buf[2];
//  399 
//  400   buf[0] = LO_UINT16( groupID );
//  401   buf[1] = HI_UINT16( groupID );
//  402 
//  403   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  404                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  405                             disableDefaultRsp, 0, seqNum, 2, buf ) );
//  406 }
//  407 
//  408 /*********************************************************************
//  409  * @fn      zclGeneral_SendAddGroupRequest
//  410  *
//  411  * @brief   Send the Add Group Request to a device
//  412  *
//  413  * @param   srcEP - Sending Apps endpoint
//  414  * @param   dstAddr - where to send the request
//  415  * @param   cmd - one of the following:
//  416  *                COMMAND_GROUP_ADD
//  417  *                COMMAND_GROUP_ADD_IF_IDENTIFYING
//  418  * @param   groupID - pointer to the group structure
//  419  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  420  *          string data type, so the first byte is the length of the
//  421  *          name (in bytes), then the name.
//  422  *
//  423  * @return  ZStatus_t
//  424  */
//  425 ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  426                                           uint8 cmd, uint16 groupID, uint8 *groupName,
//  427                                           uint8 disableDefaultRsp, uint8 seqNum )
//  428 {
//  429   uint8 *buf;
//  430   uint8 *pBuf;
//  431   uint8 len;
//  432   ZStatus_t status;
//  433 
//  434   len = 2;    // Group ID
//  435   len += groupName[0] + 1;  // String + 1 for length
//  436 
//  437   buf = zcl_mem_alloc( len );
//  438   if ( buf )
//  439   {
//  440     pBuf = buf;
//  441     *pBuf++ = LO_UINT16( groupID );
//  442     *pBuf++ = HI_UINT16( groupID );
//  443     *pBuf++ = groupName[0]; // string length
//  444     zcl_memcpy( pBuf, &(groupName[1]), groupName[0] );
//  445 
//  446     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  447                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  448                               disableDefaultRsp, 0, seqNum, len, buf );
//  449     zcl_mem_free( buf );
//  450   }
//  451   else
//  452     status = ZMemError;
//  453 
//  454   return ( status );
//  455 }
//  456 
//  457 /*********************************************************************
//  458  * @fn      zclGeneral_SendGroupGetMembershipRequest
//  459  *
//  460  * @brief   Send a Get Group Membership (Resposne) Command to a device
//  461  *
//  462  * @param   srcEP - Sending Apps endpoint
//  463  * @param   dstAddr - where to send the request
//  464  * @param   cmd - one of the following:
//  465  *                COMMAND_GROUP_GET_MEMBERSHIP
//  466  *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
//  467  * @param   groupID - pointer to the group structure
//  468  * @param   groupName - pointer to Group Name.  This is a Zigbee
//  469  *          string data type, so the first byte is the length of the
//  470  *          name (in bytes), then the name.
//  471  *
//  472  * @return  ZStatus_t
//  473  */
//  474 ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  475                                                     uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
//  476                                                     uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
//  477 {
//  478   uint8 *buf;
//  479   uint8 *pBuf;
//  480   uint8 len = 0;
//  481   uint8 i;
//  482   ZStatus_t status;
//  483 
//  484   if ( rspCmd )
//  485     len++;  // Capacity
//  486 
//  487   len++;  // Group Count
//  488   len += sizeof ( uint16 ) * grpCnt;  // Group List
//  489 
//  490   buf = zcl_mem_alloc( len );
//  491   if ( buf )
//  492   {
//  493     pBuf = buf;
//  494     if ( rspCmd )
//  495       *pBuf++ = capacity;
//  496 
//  497     *pBuf++ = grpCnt;
//  498     for ( i = 0; i < grpCnt; i++ )
//  499     {
//  500       *pBuf++ = LO_UINT16( grpList[i] );
//  501       *pBuf++ = HI_UINT16( grpList[i] );
//  502     }
//  503 
//  504     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  505                               cmd, TRUE, direction,
//  506                               disableDefaultRsp, 0, seqNum, len, buf );
//  507     zcl_mem_free( buf );
//  508   }
//  509   else
//  510     status = ZMemError;
//  511 
//  512   return ( status );
//  513 }
//  514 
//  515 /*********************************************************************
//  516  * @fn      zclGeneral_SendGroupResponse
//  517  *
//  518  * @brief   Send Group Response (not Group View Response)
//  519  *
//  520  * @param   srcEP - Sending application's endpoint
//  521  * @param   dstAddr - where you want the message to go
//  522  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  523  * @param   status - group command status
//  524  * @param   groupID - what group
//  525  *
//  526  * @return  ZStatus_t
//  527  */
//  528 ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  529                                         uint8 cmd, uint8 status, uint16 groupID,
//  530                                         uint8 disableDefaultRsp, uint8 seqNum )
//  531 {
//  532   uint8 buf[3];
//  533 
//  534   buf[0] = status;
//  535   buf[1] = LO_UINT16( groupID );
//  536   buf[2] = HI_UINT16( groupID );
//  537 
//  538   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  539                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  540                           disableDefaultRsp, 0, seqNum, 3, buf );
//  541 }
//  542 
//  543 /*********************************************************************
//  544  * @fn      zclGeneral_SendGroupViewResponse
//  545  *
//  546  * @brief   Call to send Group Response Command
//  547  *
//  548  * @param   srcEP - Sending application's endpoint
//  549  * @param   dstAddr - where you want the message to go
//  550  * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
//  551  * @param   status - group command status
//  552  * @param   grp - group info
//  553  *
//  554  * @return  ZStatus_t
//  555  */
//  556 ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  557                                             uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
//  558 {
//  559   uint8 *buf;
//  560   uint8 len;
//  561   ZStatus_t stat;
//  562 
//  563   len = 1 + 2 + 1; // Status + Group ID + name length
//  564 
//  565   if ( status == ZCL_STATUS_SUCCESS )
//  566   {
//  567     len += grp->name[0];  // String length
//  568   }
//  569 
//  570   buf = zcl_mem_alloc( len );
//  571   if ( buf )
//  572   {
//  573     buf[0] = status;
//  574     buf[1] = LO_UINT16( grp->ID );
//  575     buf[2] = HI_UINT16( grp->ID );
//  576 
//  577     if ( status == ZCL_STATUS_SUCCESS )
//  578     {
//  579       buf[3] = grp->name[0]; // string length
//  580       zcl_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
//  581     }
//  582     else //ZCL_STATUS_NOT_FOUND
//  583     {
//  584       buf[3] = 0;
//  585     }
//  586 
//  587     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
//  588                             COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  589                             disableDefaultRsp, 0, seqNum, len, buf );
//  590     zcl_mem_free( buf );
//  591   }
//  592   else
//  593   {
//  594     stat = ZMemError;
//  595   }
//  596 
//  597   return ( stat );
//  598 }
//  599 #endif // ZCL_GROUPS
//  600 
//  601 #ifdef ZCL_SCENES
//  602 /*********************************************************************
//  603  * @fn      zclGeneral_SendAddSceneRequest
//  604  *
//  605  * @brief   Send the (Enhanced) Add Scene Request to a device. You can
//  606  *           also use the appropriate macro.
//  607  *
//  608  * @param   srcEP - Sending Apps endpoint
//  609  * @param   dstAddr - where to send the request
//  610  * @param   scene - pointer to the scene structure
//  611  * @param  cmd - COMMAND_SCENE_ADD or COMMAND_SCENE_ENHANCED_ADD
//  612  * @param   disableDefaultRsp - whether to disable the Default Response command
//  613  * @param   seqNum - sequence number
//  614  *
//  615  * @return  ZStatus_t
//  616  */
//  617 ZStatus_t zclGeneral_SendAddSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  618                                           uint8 cmd, zclGeneral_Scene_t *scene,
//  619                                           uint8 disableDefaultRsp, uint8 seqNum )
//  620 {
//  621   uint8 *buf;
//  622   uint8 *pBuf;
//  623   uint8 len;
//  624   ZStatus_t status;
//  625 
//  626   len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
//  627   len += scene->name[0] + 1; // String + 1 for length
//  628 
//  629   // Add something for the extension field length
//  630   len += scene->extLen;
//  631 
//  632   buf = zcl_mem_alloc( len );
//  633   if ( buf )
//  634   {
//  635     pBuf = buf;
//  636     *pBuf++ = LO_UINT16( scene->groupID );
//  637     *pBuf++ = HI_UINT16( scene->groupID );
//  638     *pBuf++ = scene->ID;
//  639     *pBuf++ = LO_UINT16( scene->transTime );
//  640     *pBuf++ = HI_UINT16( scene->transTime );
//  641     *pBuf++ = scene->name[0]; // string length
//  642     zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  643     pBuf += scene->name[0]; // move pass name
//  644 
//  645     // Add the extension fields
//  646     if ( scene->extLen > 0 )
//  647       zcl_memcpy( pBuf, scene->extField, scene->extLen );
//  648 
//  649     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  650                               cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  651                               disableDefaultRsp, 0, seqNum, len, buf );
//  652     zcl_mem_free( buf );
//  653   }
//  654   else
//  655     status = ZMemError;
//  656 
//  657   return ( status );
//  658 }
//  659 
//  660 /*********************************************************************
//  661  * @fn      zclGeneral_SendSceneRequest
//  662  *
//  663  * @brief   Send a Scene Request to a device.  You can also use the
//  664  *          appropriate macro.
//  665  *
//  666  * @param   srcEP - Sending Apps endpoint
//  667  * @param   dstAddr - where to send the request
//  668  * @param   cmd - one of the following:
//  669  *              COMMAND_SCENE_VIEW
//  670  *              COMMAND_SCENE_REMOVE
//  671  *              COMMAND_SCENE_REMOVE_ALL
//  672  *              COMMAND_SCENE_STORE
//  673  *              COMMAND_SCENE_RECALL
//  674  *              COMMAND_SCENE_GET_MEMBERSHIP
//  675  *              COMMAND_SCENE_ENHANCED_VIEW
//  676  * @param   groupID - group ID
//  677  * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
//  678  *                    COMMAND_SCENE_GET_MEMBERSHIP)
//  679  * @param   disableDefaultRsp - whether to disable the Default Response command
//  680  * @param   seqNum - sequence number
//  681  * @return  ZStatus_t
//  682  */
//  683 ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
//  684                                        uint8 cmd, uint16 groupID, uint8 sceneID,
//  685                                        uint8 disableDefaultRsp, uint8 seqNum )
//  686 {
//  687   uint8 buf[3];
//  688   uint8 len = 2;
//  689 
//  690   buf[0] = LO_UINT16( groupID );
//  691   buf[1] = HI_UINT16( groupID );
//  692 
//  693   if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
//  694   {
//  695     buf[2] = sceneID;
//  696     len++;
//  697   }
//  698 
//  699   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  700                             cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  701                             disableDefaultRsp, 0, seqNum, len, buf ) );
//  702 }
//  703 
//  704 /*********************************************************************
//  705  * @fn      zclGeneral_SendSceneResponse
//  706  *
//  707  * @brief   Send Group Response (not Group View Response)
//  708  *
//  709  * @param   srcEP - Sending application's endpoint
//  710  * @param   dstAddr - where you want the message to go
//  711  * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
//  712  *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
//  713  * @param   status - scene command status
//  714  * @param   groupID - what group
//  715  * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
//  716  *
//  717  * @return  ZStatus_t
//  718  */
//  719 ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  720                                         uint8 cmd, uint8 status, uint16 groupID,
//  721                                         uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
//  722 {
//  723   uint8 buf[4];
//  724   uint8 len = 1 + 2; // Status + Group ID
//  725 
//  726   buf[0] = status;
//  727   buf[1] = LO_UINT16( groupID );
//  728   buf[2] = HI_UINT16( groupID );
//  729 
//  730   if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
//  731   {
//  732     buf[3] = sceneID;
//  733     len++;
//  734   }
//  735 
//  736   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  737                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  738                           disableDefaultRsp, 0, seqNum, len, buf );
//  739 }
//  740 
//  741 /*********************************************************************
//  742  * @fn      zclGeneral_SendSceneViewResponse
//  743  *
//  744  * @brief   Call to send Scene (Enahced) View Response Command. You can
//  745  *           also use the appropriate macro.
//  746  *
//  747  * @param   srcEP - Sending application's endpoint
//  748  * @param   dstAddr - where you want the message to go
//  749  * @param   cmd - either COMMAND_SCENE_VIEW_RSP or COMMAND_SCENE_ENHANCED_VIEW_RSP
//  750  * @param   status - scene command status
//  751  * @param   scene - scene info
//  752  *
//  753  * @return  ZStatus_t
//  754  */
//  755 ZStatus_t zclGeneral_SendSceneViewRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  756                                        uint8 cmd, uint8 status, zclGeneral_Scene_t *scene,
//  757                                        uint8 disableDefaultRsp, uint8 seqNum )
//  758 {
//  759   uint8 *buf;
//  760   uint8 *pBuf;
//  761   uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
//  762   ZStatus_t stat;
//  763 
//  764   if ( status == ZCL_STATUS_SUCCESS )
//  765   {
//  766     len += 2; // Transition Time
//  767     len += scene->name[0] + 1; // string + 1 for length
//  768 
//  769     // Add something for the extension field length
//  770     len += scene->extLen;
//  771   }
//  772 
//  773   buf = zcl_mem_alloc( len );
//  774   if ( buf )
//  775   {
//  776     pBuf = buf;
//  777     *pBuf++ = status;
//  778     *pBuf++ = LO_UINT16( scene->groupID );
//  779     *pBuf++ = HI_UINT16( scene->groupID );
//  780     *pBuf++ = scene->ID;
//  781     if ( status == ZCL_STATUS_SUCCESS )
//  782     {
//  783       uint16 transTime = scene->transTime;
//  784       if ( cmd == COMMAND_SCENE_ENHANCED_VIEW_RSP )
//  785       {
//  786         // Transition time is in 1/10s
//  787         transTime *= 10;
//  788         transTime += scene->transTime100ms;
//  789       }
//  790 
//  791       *pBuf++ = LO_UINT16( transTime );
//  792       *pBuf++ = HI_UINT16( transTime );
//  793       *pBuf++ = scene->name[0]; // string length
//  794       if ( scene->name[0] != 0 )
//  795       {
//  796         zcl_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
//  797         pBuf += scene->name[0]; // move pass name
//  798       }
//  799 
//  800       // Add the extension fields
//  801       if ( scene->extLen > 0 )
//  802         zcl_memcpy( pBuf, scene->extField, scene->extLen );
//  803     }
//  804 
//  805     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  806                             cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  807                             disableDefaultRsp, 0, seqNum, len, buf );
//  808     zcl_mem_free( buf );
//  809   }
//  810   else
//  811     stat = ZMemError;
//  812 
//  813   return ( stat );
//  814 }
//  815 
//  816 /*********************************************************************
//  817  * @fn      zclGeneral_SendSceneGetMembershipResponse
//  818  *
//  819  * @brief   Call to send Scene Get Membership Response Command
//  820  *
//  821  * @param   srcEP - Sending application's endpoint
//  822  * @param   dstAddr - where you want the message to go
//  823  * @param   status - scene command status
//  824  * @param   capacity - remaining capacity of the scene table
//  825  * @param   sceneCnt - number of scenes in the scene list
//  826  * @param   sceneList - list of scene IDs
//  827  * @param   groupID - group ID that scene belongs to
//  828  * @param   seqNum - sequence number
//  829  *
//  830  * @return  ZStatus_t
//  831  */
//  832 ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  833                                                      uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
//  834                                                      uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
//  835 {
//  836   uint8 *buf;
//  837   uint8 *pBuf;
//  838   uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
//  839   uint8 i;
//  840   ZStatus_t stat;
//  841 
//  842   if ( status == ZCL_STATUS_SUCCESS )
//  843   {
//  844     len++; // Scene Count
//  845     len += sceneCnt; // Scene List (Scene ID is a single octet)
//  846   }
//  847 
//  848   buf = zcl_mem_alloc( len );
//  849   if ( buf )
//  850   {
//  851     pBuf = buf;
//  852     *pBuf++ = status;
//  853     *pBuf++ = capacity;
//  854     *pBuf++ = LO_UINT16( groupID );
//  855     *pBuf++ = HI_UINT16( groupID );
//  856     if ( status == ZCL_STATUS_SUCCESS )
//  857     {
//  858       *pBuf++ = sceneCnt;
//  859       for ( i = 0; i < sceneCnt; i++ )
//  860         *pBuf++ = sceneList[i];
//  861     }
//  862 
//  863     stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  864                             COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
//  865                             ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
//  866     zcl_mem_free( buf );
//  867   }
//  868   else
//  869     stat = ZMemError;
//  870 
//  871   return ( stat );
//  872 }
//  873 
//  874 #ifdef ZCL_LIGHT_LINK_ENHANCE
//  875 /*********************************************************************
//  876  * @fn      zclGeneral_SendSceneCopy
//  877  *
//  878  * @brief   Send Scene Copy Request to a device
//  879  *
//  880  * @param   srcEP - sending application's endpoint
//  881  * @param   dstAddr - where to send the request
//  882  * @param   mode - how scene copy is to proceed
//  883  * @param   groupIDFrom - group from which scene to be copied
//  884  * @param   sceneIDFrom - scene from which scene to be copied
//  885  * @param   groupIDTo - group to which scene to be copied
//  886  * @param   sceneIDTo - scene to which scene to be copied
//  887  * @param   disableDefaultRsp - disable Default Response command
//  888  * @param   seqNum - the identification number for the transaction
//  889  *
//  890  * @return  ZStatus_t
//  891  */
//  892 ZStatus_t zclGeneral_SendSceneCopy( uint8 srcEP, afAddrType_t *dstAddr,
//  893                                     uint8 mode, uint16 groupIDFrom, uint8 sceneIDFrom,
//  894                                     uint16 groupIDTo, uint8 sceneIDTo,
//  895                                     uint8 disableDefaultRsp, uint8 seqNum )
//  896 {
//  897   uint8 buf[7];
//  898 
//  899   buf[0] = mode;
//  900   buf[1] = LO_UINT16( groupIDFrom );
//  901   buf[2] = HI_UINT16( groupIDFrom );
//  902   buf[3] = sceneIDFrom;
//  903   buf[4] = LO_UINT16( groupIDTo );
//  904   buf[5] = HI_UINT16( groupIDTo );
//  905   buf[6] = sceneIDTo;
//  906 
//  907   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  908                             COMMAND_SCENE_COPY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  909                             disableDefaultRsp, 0, seqNum, 7, buf ) );
//  910 }
//  911 
//  912 /*********************************************************************
//  913  * @fn      zclGeneral_SendSceneCopyResponse
//  914  *
//  915  * @brief   Send Scene Copy Response to a device
//  916  *
//  917  * @param   srcEP - sending application's endpoint
//  918  * @param   dstAddr - where to send the request
//  919  * @param   status - status of copy scene attemp
//  920  * @param   groupIDFrom - group from which scene was copied
//  921  * @param   sceneIDFrom - scene from which scene was copied
//  922  * @param   disableDefaultRsp - disable Default Response command
//  923  * @param   seqNum - the identification number for the transaction
//  924  *
//  925  * @return  ZStatus_t
//  926  */
//  927 ZStatus_t zclGeneral_SendSceneCopyResponse( uint8 srcEP, afAddrType_t *dstAddr,
//  928                                             uint8 status, uint16 groupIDFrom, uint8 sceneIDFrom,
//  929                                             uint8 disableDefaultRsp, uint8 seqNum )
//  930 {
//  931   uint8 buf[4];
//  932 
//  933   buf[0] = status;
//  934   buf[1] = LO_UINT16( groupIDFrom );
//  935   buf[2] = HI_UINT16( groupIDFrom );
//  936   buf[3] = sceneIDFrom;
//  937 
//  938   return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
//  939                             COMMAND_SCENE_COPY_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  940                             disableDefaultRsp, 0, seqNum, 4, buf ) );
//  941 }
//  942 #endif // ZCL_LIGHT_LINK_ENHANCE
//  943 #endif // ZCL_SCENES
//  944 
//  945 #ifdef ZCL_ON_OFF
//  946 #ifdef ZCL_LIGHT_LINK_ENHANCE
//  947 /*********************************************************************
//  948  * @fn      zclGeneral_SendOnOff_CmdOffWithEffect
//  949  *
//  950  * @brief   Call to send out an Off with Effect Command.
//  951  *
//  952  * @param   srcEP - Sending application's endpoint
//  953  * @param   dstAddr - where you want the message to go
//  954  * @param   effectId - fading effect to use when switching light off
//  955  * @param   effectVariant - which variant of effect to be triggered
//  956  * @param   disableDefaultRsp - whether to disable the Default Response command
//  957  * @param   seqNum - sequence number
//  958  *
//  959  * @return  ZStatus_t
//  960  */
//  961 ZStatus_t zclGeneral_SendOnOff_CmdOffWithEffect( uint8 srcEP, afAddrType_t *dstAddr,
//  962                                                  uint8 effectId, uint8 effectVariant,
//  963                                                  uint8 disableDefaultRsp, uint8 seqNum )
//  964 {
//  965   uint8 buf[2];
//  966 
//  967   buf[0] = effectId;
//  968   buf[1] = effectVariant;
//  969 
//  970   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
//  971                           COMMAND_OFF_WITH_EFFECT, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
//  972                           disableDefaultRsp, 0, seqNum, 2, buf );
//  973 }
//  974 
//  975 /*********************************************************************
//  976  * @fn      zclGeneral_SendOnOff_CmdOnWithTimedOff
//  977  *
//  978  * @brief   Call to send out an On with Timed Off Command.
//  979  *
//  980  * @param   srcEP - Sending application's endpoint
//  981  * @param   dstAddr - where you want the message to go
//  982  * @param   onOffCtrl - how the lamp is to be operated
//  983  * @param   onTime - the length of time (in 1/10ths second) that the lamp is to remain on, before automatically turning off
//  984  * @param   offWaitTime - the length of time (in 1/10ths second) that the lamp shall remain off, and guarded to prevent an on command turning the light back on.
//  985  * @param   disableDefaultRsp - whether to disable the Default Response command
//  986  * @param   seqNum - sequence number
//  987  *
//  988  * @return  ZStatus_t
//  989  */
//  990 ZStatus_t zclGeneral_SendOnOff_CmdOnWithTimedOff ( uint8 srcEP, afAddrType_t *dstAddr,
//  991                                                    zclOnOffCtrl_t onOffCtrl, uint16 onTime, uint16 offWaitTime,
//  992                                                    uint8 disableDefaultRsp, uint8 seqNum )
//  993 {
//  994   uint8 buf[5];
//  995 
//  996   buf[0] = onOffCtrl.byte;
//  997   buf[1] = LO_UINT16( onTime );
//  998   buf[2] = HI_UINT16( onTime );
//  999   buf[3] = LO_UINT16( offWaitTime );
// 1000   buf[4] = HI_UINT16( offWaitTime );
// 1001 
// 1002   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ON_OFF,
// 1003                           COMMAND_ON_WITH_TIMED_OFF, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1004                           disableDefaultRsp, 0, seqNum, 5, buf );
// 1005 }
// 1006 #endif // ZCL_LIGHT_LINK_ENHANCE
// 1007 #endif // ZCL_ON_OFF
// 1008 
// 1009 #ifdef ZCL_LEVEL_CTRL
// 1010 /*********************************************************************
// 1011  * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
// 1012  *
// 1013  * @brief   Call to send out a Level Control Request. You can also use
// 1014  *          the appropriate macro.
// 1015  *
// 1016  * @param   srcEP - Sending application's endpoint
// 1017  * @param   dstAddr - where you want the message to go
// 1018  * @param   cmd - one of the following:
// 1019  *              COMMAND_LEVEL_MOVE_TO_LEVEL or
// 1020  *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
// 1021  * @param   level - what level to move to
// 1022  * @param   transitionTime - how long to take to get to the level (in seconds)
// 1023  *
// 1024  * @return  ZStatus_t
// 1025  */
// 1026 ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
// 1027                                                          uint8 cmd, uint8 level, uint16 transTime,
// 1028                                                          uint8 disableDefaultRsp, uint8 seqNum )
// 1029 {
// 1030   uint8 buf[3];
// 1031 
// 1032   buf[0] = level;
// 1033   buf[1] = LO_UINT16( transTime );
// 1034   buf[2] = HI_UINT16( transTime );
// 1035 
// 1036   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
// 1037                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1038                           disableDefaultRsp, 0, seqNum, 3, buf );
// 1039 }
// 1040 
// 1041 /*********************************************************************
// 1042  * @fn      zclGeneral_SendLevelControlMoveRequest
// 1043  *
// 1044  * @brief   Call to send out a Level Control Request. You can also use
// 1045  *          the appropriate macro.
// 1046  *
// 1047  * @param   srcEP - Sending application's endpoint
// 1048  * @param   dstAddr - where you want the message to go
// 1049  * @param   cmd - one of the following:
// 1050  *              COMMAND_LEVEL_MOVE or
// 1051  *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
// 1052  * @param   moveMode - LEVEL_MOVE_UP or
// 1053  *                     LEVEL_MOVE_DOWN
// 1054  * @param   rate - number of steps to take per second
// 1055  *
// 1056  * @return  ZStatus_t
// 1057  */
// 1058 ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
// 1059                                                   uint8 cmd, uint8 moveMode, uint8 rate,
// 1060                                                   uint8 disableDefaultRsp, uint8 seqNum )
// 1061 {
// 1062   uint8 buf[2];
// 1063 
// 1064   buf[0] = moveMode;
// 1065   buf[1] = rate;
// 1066 
// 1067   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
// 1068                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1069                           disableDefaultRsp, 0, seqNum, 2, buf );
// 1070 }
// 1071 
// 1072 /*********************************************************************
// 1073  * @fn      zclGeneral_SendLevelControlStepRequest
// 1074  *
// 1075  * @brief   Call to send out a Level Control Request. You can also use
// 1076  *          the appropriate macro.
// 1077  *
// 1078  * @param   srcEP - Sending application's endpoint
// 1079  * @param   dstAddr - where you want the message to go
// 1080  * @param   cmd - one of the following:
// 1081  *              COMMAND_LEVEL_STEP
// 1082  *              COMMAND_LEVEL_STEP_WITH_ON_OFF
// 1083  * @param   stepMode - LEVEL_STEP_UP or
// 1084  *                     LEVEL_STEP_DOWN
// 1085  * @param   amount - number of levels to step
// 1086  * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
// 1087  *
// 1088  * @return  ZStatus_t
// 1089  */
// 1090 ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
// 1091                                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
// 1092                                                   uint8 disableDefaultRsp, uint8 seqNum )
// 1093 {
// 1094   uint8 buf[4];
// 1095 
// 1096   buf[0] = stepMode;
// 1097   buf[1] = stepSize;
// 1098   buf[2] = LO_UINT16( transTime );
// 1099   buf[3] = HI_UINT16( transTime );
// 1100 
// 1101   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
// 1102                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1103                           disableDefaultRsp, 0, seqNum, 4, buf );
// 1104 }
// 1105 
// 1106 /*********************************************************************
// 1107  * @fn      zclGeneral_SendLevelControlStepRequest
// 1108  *
// 1109  * @brief   Call to send out a Level Control Request. You can also use
// 1110  *          the appropriate macro.
// 1111  *
// 1112  * @param   srcEP - Sending application's endpoint
// 1113  * @param   dstAddr - where you want the message to go
// 1114  * @param   cmd - one of the following:
// 1115  *              COMMAND_LEVEL_STOP
// 1116  *              COMMAND_LEVEL_STOP_WITH_ON_OFF
// 1117  *
// 1118  * @return  ZStatus_t
// 1119  */
// 1120 ZStatus_t zclGeneral_SendLevelControlStopRequest( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1121                                                   uint8 disableDefaultRsp, uint8 seqNum )
// 1122 {
// 1123   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
// 1124                           cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1125                           disableDefaultRsp, 0, seqNum, 0, NULL );
// 1126 }
// 1127 #endif // ZCL_LEVEL_CTRL
// 1128 
// 1129 #ifdef ZCL_ALARMS
// 1130 /*********************************************************************
// 1131  * @fn      zclGeneral_SendAlarm
// 1132  *
// 1133  * @brief   Call to send out an Alarm Request Command
// 1134  *
// 1135  * @param   srcEP - Sending application's endpoint
// 1136  * @param   dstAddr - where you want the message to go
// 1137  * @param   cmd - COMMAND_ALARMS_ALARM
// 1138  * @param   alarmCode - code for the cause of the alarm
// 1139  * @param   clusterID - cluster whose attribute generate the alarm
// 1140  *
// 1141  * @return  ZStatus_t
// 1142  */
// 1143 ZStatus_t zclGeneral_SendAlarm( uint8 srcEP, afAddrType_t *dstAddr,
// 1144                                 uint8 alarmCode, uint16 clusterID,
// 1145                                 uint8 disableDefaultRsp, uint8 seqNum )
// 1146 {
// 1147   uint8 buf[3];
// 1148 
// 1149   buf[0] = alarmCode;
// 1150   buf[1] = LO_UINT16( clusterID );
// 1151   buf[2] = HI_UINT16( clusterID );
// 1152 
// 1153   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1154                           COMMAND_ALARMS_ALARM, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1155                           disableDefaultRsp, 0, seqNum, 3, buf );
// 1156 }
// 1157 
// 1158 /*********************************************************************
// 1159  * @fn      zclGeneral_SendAlarmReset
// 1160  *
// 1161  * @brief   Call to send out an Alarm Reset Command
// 1162  *
// 1163  * @param   srcEP - Sending application's endpoint
// 1164  * @param   dstAddr - where you want the message to go
// 1165  * @param   alarmCode - code for the cause of the alarm
// 1166  * @param   clusterID - cluster whose attribute generate the alarm
// 1167  *
// 1168  * @return  ZStatus_t
// 1169 */
// 1170 ZStatus_t zclGeneral_SendAlarmReset( uint8 srcEP, afAddrType_t *dstAddr,
// 1171                                      uint8 alarmCode, uint16 clusterID,
// 1172                                      uint8 disableDefaultRsp, uint8 seqNum )
// 1173 {
// 1174   uint8 buf[3];
// 1175 
// 1176   buf[0] = alarmCode;
// 1177   buf[1] = LO_UINT16( clusterID );
// 1178   buf[2] = HI_UINT16( clusterID );
// 1179 
// 1180   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1181                           COMMAND_ALARMS_RESET, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1182                           disableDefaultRsp, 0, seqNum, 3, buf );
// 1183 }
// 1184 
// 1185 /*********************************************************************
// 1186  * @fn      zclGeneral_SendAlarmGetResponse
// 1187  *
// 1188  * @brief   Call to send out an Alarm Get Response Command
// 1189  *
// 1190  * @param   srcEP - Sending application's endpoint
// 1191  * @param   dstAddr - where you want the message to go
// 1192  * @param   status - SUCCESS or NOT_FOUND
// 1193  * @param   alarmCode - code for the cause of the alarm
// 1194  * @param   clusterID - cluster whose attribute generate the alarm
// 1195  * @param   timeStamp - time at which the alarm occured
// 1196  *
// 1197  * @return  ZStatus_t
// 1198  */
// 1199 ZStatus_t zclGeneral_SendAlarmGetResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1200                                            uint8 status, uint8 alarmCode, uint16 clusterID,
// 1201                                            uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
// 1202 {
// 1203   uint8 buf[8];
// 1204   uint8 len = 1; // Status
// 1205 
// 1206   buf[0] = status;
// 1207   if ( status == ZCL_STATUS_SUCCESS )
// 1208   {
// 1209     len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
// 1210     buf[1] = alarmCode;
// 1211     buf[2] = LO_UINT16( clusterID );
// 1212     buf[3] = HI_UINT16( clusterID );
// 1213     zcl_buffer_uint32( &buf[4], timeStamp );
// 1214   }
// 1215 
// 1216   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1217                           COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1218                           disableDefaultRsp, 0, seqNum, len, buf );
// 1219 }
// 1220 
// 1221 #ifdef SE_UK_EXT
// 1222 /*********************************************************************
// 1223  * @fn      zclGeneral_SendAlarmGetEventLog
// 1224  *
// 1225  * @brief   Call to send out an Alarm Get Event Log Command
// 1226  *
// 1227  * @param   srcEP - Sending application's endpoint
// 1228  * @param   dstAddr - where you want the message to go
// 1229  * @param   pEventLog - pointer to Get Event Log Command
// 1230  * @param   disableDefaultRsp - disable default response
// 1231  * @param   seqNum - ZCL sequence number
// 1232  *
// 1233  * @return  ZStatus_t
// 1234  */
// 1235 ZStatus_t zclGeneral_SendAlarmGetEventLog( uint8 srcEP, afAddrType_t *dstAddr,
// 1236                                            zclGetEventLog_t *pEventLog,
// 1237                                            uint8 disableDefaultRsp, uint8 seqNum )
// 1238 {
// 1239   uint8 buf[10];
// 1240 
// 1241   buf[0] = pEventLog->logID;
// 1242   zcl_buffer_uint32( &buf[1], pEventLog->startTime );
// 1243   zcl_buffer_uint32( &buf[5], pEventLog->endTime );
// 1244   buf[9] = pEventLog->numEvents;
// 1245 
// 1246   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1247                           COMMAND_ALARMS_GET_EVENT_LOG, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1248                           disableDefaultRsp, 0, seqNum, 10, buf );
// 1249 }
// 1250 
// 1251 /*********************************************************************
// 1252  * @fn      zclGeneral_SendAlarmPublishEventLog
// 1253  *
// 1254  * @brief   Call to send out an Alarm Publish Event Log Command
// 1255  *
// 1256  * @param   srcEP - Sending application's endpoint
// 1257  * @param   dstAddr - where you want the message to go
// 1258  * @param   pEventLog - pointer to Publish Event Log Command
// 1259  * @param   disableDefaultRsp - disable default response
// 1260  * @param   seqNum - ZCL sequence number
// 1261  *
// 1262  * @return  ZStatus_t
// 1263  */
// 1264 ZStatus_t zclGeneral_SendAlarmPublishEventLog( uint8 srcEP, afAddrType_t *dstAddr,
// 1265                                                zclPublishEventLog_t *pEventLog,
// 1266                                                uint8 disableDefaultRsp, uint8 seqNum )
// 1267 {
// 1268   uint8 *buf;
// 1269   uint8 *pBuf;
// 1270   uint8 bufLen;
// 1271 
// 1272   // Log ID + Command Index + Total Commands + (numSubLogs * ( Event ID + Event Time))
// 1273   bufLen = 1 + 1 + 1 + (pEventLog->numSubLogs * (1 + 4));
// 1274 
// 1275   buf = zcl_mem_alloc( bufLen );
// 1276   if ( buf == NULL )
// 1277   {
// 1278     return (ZMemError);
// 1279   }
// 1280 
// 1281   pBuf = buf;
// 1282   *pBuf++ = pEventLog->logID;
// 1283   *pBuf++ = pEventLog->cmdIndex;
// 1284   *pBuf++ = pEventLog->totalCmds;
// 1285 
// 1286   for ( uint8 i = 0; i < pEventLog->numSubLogs; i++ )
// 1287   {
// 1288     zclEventLogPayload_t *pLogs = &(pEventLog->pLogs[i]);
// 1289 
// 1290     *pBuf++ = pLogs->eventId;
// 1291     pBuf = zcl_buffer_uint32( pBuf, pLogs->eventTime );
// 1292   }
// 1293 
// 1294   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
// 1295                           COMMAND_ALARMS_PUBLISH_EVENT_LOG, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
// 1296                           disableDefaultRsp, 0, seqNum, bufLen, buf );
// 1297 }
// 1298 #endif // SE_UK_EXT
// 1299 #endif // ZCL_ALARMS
// 1300 
// 1301 #ifdef ZCL_LOCATION
// 1302 /*********************************************************************
// 1303  * @fn      zclGeneral_SendLocationSetAbsolute
// 1304  *
// 1305  * @brief   Call to send out a Set Absolute Location Command
// 1306  *
// 1307  * @param   srcEP - Sending application's endpoint
// 1308  * @param   dstAddr - where you want the message to go
// 1309  * @param   absLoc - absolute location info
// 1310  *
// 1311  * @return  ZStatus_t
// 1312  */
// 1313 ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
// 1314                                               zclLocationAbsolute_t *absLoc,
// 1315                                               uint8 disableDefaultRsp, uint8 seqNum )
// 1316 {
// 1317    uint8 buf[10]; // 5 fields (2 octects each)
// 1318 
// 1319    buf[0] = LO_UINT16( absLoc->coordinate1 );
// 1320    buf[1] = HI_UINT16( absLoc->coordinate1 );
// 1321    buf[2] = LO_UINT16( absLoc->coordinate2 );
// 1322    buf[3] = HI_UINT16( absLoc->coordinate2 );
// 1323    buf[4] = LO_UINT16( absLoc->coordinate3 );
// 1324    buf[5] = HI_UINT16( absLoc->coordinate3 );
// 1325    buf[6] = LO_UINT16( absLoc->power );
// 1326    buf[7] = HI_UINT16( absLoc->power );
// 1327    buf[8] = LO_UINT16( absLoc->pathLossExponent );
// 1328    buf[9] = HI_UINT16( absLoc->pathLossExponent );
// 1329 
// 1330    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1331                            COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
// 1332                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
// 1333 }
// 1334 
// 1335 /*********************************************************************
// 1336  * @fn      zclGeneral_SendLocationSetDevCfg
// 1337  *
// 1338  * @brief   Call to send out a Set Device Configuration Command
// 1339  *
// 1340  * @param   srcEP - Sending application's endpoint
// 1341  * @param   dstAddr - where you want the message to go
// 1342  * @param   devCfg - device configuration info
// 1343  *
// 1344  * @return  ZStatus_t
// 1345  */
// 1346 ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
// 1347                                             zclLocationDevCfg_t *devCfg,
// 1348                                             uint8 disableDefaultRsp, uint8 seqNum )
// 1349 {
// 1350    uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
// 1351 
// 1352    buf[0] = LO_UINT16( devCfg->power );
// 1353    buf[1] = HI_UINT16( devCfg->power );
// 1354    buf[2] = LO_UINT16( devCfg->pathLossExponent );
// 1355    buf[3] = HI_UINT16( devCfg->pathLossExponent );
// 1356    buf[4] = LO_UINT16( devCfg->calcPeriod );
// 1357    buf[5] = HI_UINT16( devCfg->calcPeriod );
// 1358    buf[6] = devCfg->numMeasurements;
// 1359    buf[7] = LO_UINT16( devCfg->reportPeriod );
// 1360    buf[8] = HI_UINT16( devCfg->reportPeriod );
// 1361 
// 1362    return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1363                            COMMAND_LOCATION_SET_DEV_CFG, TRUE,
// 1364                            ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
// 1365 }
// 1366 
// 1367 /*********************************************************************
// 1368  * @fn      zclGeneral_SendLocationGetDevCfg
// 1369  *
// 1370  * @brief   Call to send out a Get Device Configuration Command
// 1371  *
// 1372  * @param   srcEP - Sending application's endpoint
// 1373  * @param   dstAddr - where you want the message to go
// 1374  * @param   targetAddr - device for which location parameters are being requested
// 1375  *
// 1376  * @return  ZStatus_t
// 1377  */
// 1378 ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
// 1379                                             uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
// 1380 {
// 1381   uint8 buf[8];
// 1382 
// 1383   zcl_memcpy( buf, targetAddr, 8 );
// 1384 
// 1385   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1386                           COMMAND_LOCATION_GET_DEV_CFG, TRUE,
// 1387                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
// 1388 }
// 1389 
// 1390 /*********************************************************************
// 1391  * @fn      zclGeneral_SendLocationGetData
// 1392  *
// 1393  * @brief   Call to send out a Get Location Data Command
// 1394  *
// 1395  * @param   srcEP - Sending application's endpoint
// 1396  * @param   dstAddr - where you want the message to go
// 1397  * @param   locaData - location information and channel parameters that are requested.
// 1398  *
// 1399  * @return  ZStatus_t
// 1400  */
// 1401 ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
// 1402                                           zclLocationGetData_t *locData,
// 1403                                           uint8 disableDefaultRsp, uint8 seqNum )
// 1404 {
// 1405   uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
// 1406   uint8 *pBuf = buf;
// 1407   uint8 len = 2; // bitmap + number responses
// 1408 
// 1409   *pBuf  = locData->absoluteOnly;
// 1410   *pBuf |= locData->recalculate << 1;
// 1411   *pBuf |= locData->brdcastIndicator << 2;
// 1412   *pBuf |= locData->brdcastResponse << 3;
// 1413   *pBuf |= locData->compactResponse << 4;
// 1414   pBuf++;  // move past the bitmap field
// 1415 
// 1416   *pBuf++ = locData->numResponses;
// 1417 
// 1418   if ( locData->brdcastIndicator == 0 )
// 1419   {
// 1420     zcl_memcpy( pBuf, locData->targetAddr, 8 );
// 1421     len += 8; // ieee addr
// 1422   }
// 1423 
// 1424   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1425                           COMMAND_LOCATION_GET_DATA, TRUE,
// 1426                           ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1427 }
// 1428 
// 1429 /*********************************************************************
// 1430  * @fn      zclGeneral_SendLocationDevCfgResponse
// 1431  *
// 1432  * @brief   Call to send out a Device Configuration Response Command
// 1433  *
// 1434  * @param   srcEP - Sending application's endpoint
// 1435  * @param   dstAddr - where you want the message to go
// 1436  * @param   devCfg - device's location parameters that are requested
// 1437  *
// 1438  * @return  ZStatus_t
// 1439  */
// 1440 ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
// 1441                                                  zclLocationDevCfgRsp_t *devCfg,
// 1442                                                  uint8 disableDefaultRsp, uint8 seqNum )
// 1443 {
// 1444   uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
// 1445   uint8 len = 1; // Status
// 1446 
// 1447   buf[0] = devCfg->status;
// 1448   if ( devCfg->status == ZCL_STATUS_SUCCESS )
// 1449   {
// 1450     buf[1] = LO_UINT16( devCfg->data.power );
// 1451     buf[2] = HI_UINT16( devCfg->data.power );
// 1452     buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
// 1453     buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
// 1454     buf[5] = LO_UINT16( devCfg->data.calcPeriod );
// 1455     buf[6] = HI_UINT16( devCfg->data.calcPeriod );
// 1456     buf[7] = devCfg->data.numMeasurements;
// 1457     buf[8] = LO_UINT16( devCfg->data.reportPeriod );
// 1458     buf[9] = HI_UINT16( devCfg->data.reportPeriod );
// 1459     len += 9;
// 1460   }
// 1461 
// 1462   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1463                           COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
// 1464                           ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
// 1465 }
// 1466 
// 1467 /*********************************************************************
// 1468  * @fn      zclGeneral_SendLocationData
// 1469  *
// 1470  * @brief   Call to send out location data
// 1471  *
// 1472  * @param   srcEP - Sending application's endpoint
// 1473  * @param   dstAddr - where you want the message to go
// 1474  * @param   status - indicates whether response to request was successful or not
// 1475  * @param   locData - location information and channel parameters being sent
// 1476  *
// 1477  * @return  ZStatus_t
// 1478  */
// 1479 ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
// 1480                                        uint8 status, zclLocationData_t *locData,
// 1481                                        uint8 disableDefaultRsp, uint8 seqNum )
// 1482 {
// 1483   uint8 buf[16];
// 1484   uint8 *pBuf = buf;
// 1485   uint8 len = 0;
// 1486 
// 1487   if ( cmd == COMMAND_LOCATION_DATA_RSP )
// 1488   {
// 1489     // Only response command includes a status field
// 1490     *pBuf++ = status;
// 1491     len++;
// 1492   }
// 1493 
// 1494   if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
// 1495   {
// 1496     // Notification or Response with successful status
// 1497     *pBuf++ = locData->type;
// 1498     *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
// 1499     *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
// 1500     *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
// 1501     *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
// 1502     len += 5;
// 1503 
// 1504     if ( locationType2D(locData->type) == 0 )
// 1505     {
// 1506       // 2D location doesn't have coordinate 3
// 1507       *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
// 1508       *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
// 1509       len += 2;
// 1510     }
// 1511 
// 1512     if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1513     {
// 1514       // Compact notification doesn't include these fields
// 1515       *pBuf++ = LO_UINT16( locData->absLoc.power );
// 1516       *pBuf++ = HI_UINT16( locData->absLoc.power );
// 1517       *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
// 1518       *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
// 1519       len += 4;
// 1520     }
// 1521 
// 1522     if ( locationTypeAbsolute(locData->type) == 0 )
// 1523     {
// 1524       // Absolute location doesn't include these fields
// 1525       if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 1526       {
// 1527         // Compact notification doesn't include this field
// 1528         *pBuf++ = locData->calcLoc.locationMethod;
// 1529         len++;
// 1530       }
// 1531 
// 1532       *pBuf++ = locData->calcLoc.qualityMeasure;
// 1533       *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
// 1534       *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
// 1535       len += 3;
// 1536     }
// 1537   }
// 1538 
// 1539   return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
// 1540                           cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1541                           disableDefaultRsp, 0, seqNum, len, buf );
// 1542 }
// 1543 #endif // ZCL_LOCATION
// 1544 
// 1545 /*********************************************************************
// 1546  * @fn      zclGeneral_FindCallbacks
// 1547  *
// 1548  * @brief   Find the callbacks for an endpoint
// 1549  *
// 1550  * @param   endpoint - endpoint to find the application callbacks for
// 1551  *
// 1552  * @return  pointer to the callbacks
// 1553  */
// 1554 static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
// 1555 {
// 1556   zclGenCBRec_t *pCBs;
// 1557 
// 1558   pCBs = zclGenCBs;
// 1559   while ( pCBs )
// 1560   {
// 1561     if ( pCBs->endpoint == endpoint )
// 1562       return ( pCBs->CBs );
// 1563     pCBs = pCBs->next;
// 1564   }
// 1565   return ( (zclGeneral_AppCallbacks_t *)NULL );
// 1566 }
// 1567 
// 1568 /*********************************************************************
// 1569  * @fn      zclGeneral_HdlIncoming
// 1570  *
// 1571  * @brief   Callback from ZCL to process incoming Commands specific
// 1572  *          to this cluster library or Profile commands for attributes
// 1573  *          that aren't in the attribute list
// 1574  *
// 1575  *
// 1576  * @param   pInMsg - pointer to the incoming message
// 1577  *
// 1578  * @return  ZStatus_t
// 1579  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1580 static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
zclGeneral_HdlIncoming:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function zclGeneral_HdlIncoming
        CODE
// 1581 {
        FUNCALL zclGeneral_HdlIncoming, zclGeneral_HdlInSpecificCommands
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1582   ZStatus_t stat = ZSuccess;
// 1583 
// 1584 #if defined ( INTER_PAN )
// 1585   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
// 1586     return ( stat ); // Cluster not supported thru Inter-PAN
// 1587 #endif
// 1588   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x7
        XRL     A,#0x1
        JNZ     ??zclGeneral_HdlIncoming_0
// 1589   {
// 1590     // Is this a manufacturer specific command?
// 1591     if ( pInMsg->hdr.fc.manuSpecific == 0 )
// 1592     {
// 1593       stat = zclGeneral_HdlInSpecificCommands( pInMsg );
        ; Setup parameters for call to function zclGeneral_HdlInSpecificCommands
        LCALL   `??zclGeneral_HdlInSpecificCommands::?relay`; Banked call to: zclGeneral_HdlInSpecificCommands
        MOV     A,R1
        MOV     R1,A
        SJMP    ??zclGeneral_HdlIncoming_1
// 1594     }
// 1595     else
// 1596     {
// 1597       // We don't support any manufacturer specific command.
// 1598       stat = ZFailure;
// 1599     }
// 1600   }
// 1601   else
// 1602   {
// 1603     // Handle all the normal (Read, Write...) commands -- should never get here
// 1604     stat = ZFailure;
??zclGeneral_HdlIncoming_0:
        MOV     R1,#0x1
// 1605   }
// 1606   return ( stat );
??zclGeneral_HdlIncoming_1:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
// 1607 }
          CFI EndBlock cfiBlock1
// 1608 
// 1609 /*********************************************************************
// 1610  * @fn      zclGeneral_HdlInSpecificCommands
// 1611  *
// 1612  * @brief   Callback from ZCL to process incoming Commands specific
// 1613  *          to this cluster library
// 1614 
// 1615  * @param   pInMsg - pointer to the incoming message
// 1616  *
// 1617  * @return  ZStatus_t
// 1618  */

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1619 static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
zclGeneral_HdlInSpecificCommands:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function zclGeneral_HdlInSpecificCommands
        CODE
// 1620 {
        REQUIRE ?V0
        REQUIRE ?V1
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1621   ZStatus_t stat;
// 1622   zclGeneral_AppCallbacks_t *pCBs;
// 1623 
// 1624   // make sure endpoint exists
// 1625   pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
        MOV     DPL,R6
        MOV     DPH,R7
        LCALL   ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_3:
        MOV     R2,A
        MOV     A,R1
        MOV     R3,A
        MOV     A,R2
        ADD     A,#0x14
        MOV     DPL,A
        CLR     A
        ADDC    A,R3
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     DPTR,#zclGenCBs
??zclGeneral_HdlInSpecificCommands_0:
        LCALL   ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_2:
        ORL     A,R1
        JZ      ??zclGeneral_HdlInSpecificCommands_1
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R4
        MOV     DPL,R0
        MOV     DPH,R1
        JNZ     ??zclGeneral_HdlInSpecificCommands_0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine1 & 0xFFFF
??CrossCallReturnLabel_4:
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
// 1626   if ( pCBs == NULL )
        MOV     A,R4
        ORL     A,R5
        JZ      ??zclGeneral_HdlInSpecificCommands_1
// 1627     return ( ZFailure );
// 1628 
// 1629   switch ( pInMsg->msg->clusterId )
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V1,A
        MOV     R0,#?V0
        LCALL   ?US_SWITCH_SPARSE
`?<Jumptable for zclGeneral_HdlInSpecificComman_0`:
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        2
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        0
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_2
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        6
        DATA
        DATA16
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_3
        DATA
        DATA16
        DATA
        DATA16
        DW        ??zclGeneral_HdlInSpecificCommands_1
        CODE
// 1630   {
// 1631 #ifdef ZCL_BASIC
// 1632     case ZCL_CLUSTER_ID_GEN_BASIC:
// 1633       stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_2:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_4
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JZ      ??zclGeneral_HdlInSpecificCommands_5
??zclGeneral_HdlInSpecificCommands_1:
        MOV     R1,#0x1
        SJMP    ??zclGeneral_HdlInSpecificCommands_6
??zclGeneral_HdlInSpecificCommands_5:
        MOV     DPL,R4
        MOV     DPH,R5
        LCALL   ?Subroutine0 & 0xFFFF
??CrossCallReturnLabel_0:
        JZ      ??zclGeneral_HdlInSpecificCommands_4
        ; Setup parameters for indirect call
        LCALL   ?CALL_IND
??zclGeneral_HdlInSpecificCommands_4:
        MOV     R1,#0x0
        SJMP    ??zclGeneral_HdlInSpecificCommands_6
// 1634       break;
// 1635 #endif // ZCL_BASIC
// 1636 
// 1637 #ifdef ZCL_IDENTIFY
// 1638     case ZCL_CLUSTER_ID_GEN_IDENTIFY:
// 1639       stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
// 1640       break;
// 1641 #endif // ZCL_IDENTIFY
// 1642 
// 1643 #ifdef ZCL_GROUPS
// 1644     case ZCL_CLUSTER_ID_GEN_GROUPS:
// 1645       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1646         stat = zclGeneral_ProcessInGroupsServer( pInMsg );
// 1647       else
// 1648         stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
// 1649       break;
// 1650 #endif // ZCL_GROUPS
// 1651 
// 1652 #ifdef ZCL_SCENES
// 1653     case ZCL_CLUSTER_ID_GEN_SCENES:
// 1654       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1655         stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
// 1656       else
// 1657         stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
// 1658       break;
// 1659 #endif // ZCL_SCENES
// 1660 
// 1661 #ifdef ZCL_ON_OFF
// 1662     case ZCL_CLUSTER_ID_GEN_ON_OFF:
// 1663       stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
??zclGeneral_HdlInSpecificCommands_3:
        MOV     ?V0,#0x0
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0x8
        JNZ     ??zclGeneral_HdlInSpecificCommands_7
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        JZ      ??zclGeneral_HdlInSpecificCommands_7
        DEC     A
        JZ      ??zclGeneral_HdlInSpecificCommands_7
        DEC     A
        JNZ     ??zclGeneral_HdlInSpecificCommands_8
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        LCALL   ?Subroutine0 & 0xFFFF
??CrossCallReturnLabel_1:
        JZ      ??zclGeneral_HdlInSpecificCommands_7
        ; Setup parameters for indirect call
        MOV     A,R2
        MOV     R1,A
        LCALL   ?CALL_IND
        SJMP    ??zclGeneral_HdlInSpecificCommands_7
??zclGeneral_HdlInSpecificCommands_8:
        MOV     ?V0,#0x1
??zclGeneral_HdlInSpecificCommands_7:
        MOV     R1,?V0
// 1664       break;
// 1665 #endif // ZCL_ON_OFF
// 1666 
// 1667 #ifdef ZCL_LEVEL_CTRL
// 1668     case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
// 1669       stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
// 1670       break;
// 1671 #endif // ZCL_LEVEL_CTRL
// 1672 
// 1673 #ifdef ZCL_ALARMS
// 1674     case ZCL_CLUSTER_ID_GEN_ALARMS:
// 1675       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1676         stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
// 1677       else
// 1678         stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
// 1679       break;
// 1680 #endif // ZCL_ALARMS
// 1681 
// 1682 #ifdef ZCL_LOCATION
// 1683     case ZCL_CLUSTER_ID_GEN_LOCATION:
// 1684       if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1685         stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
// 1686       else
// 1687         stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
// 1688       break;
// 1689 #endif // ZCL_LOCATION
// 1690 
// 1691     case ZCL_CLUSTER_ID_GEN_POWER_CFG:
// 1692     case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
// 1693     case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
// 1694     case ZCL_CLUSTER_ID_GEN_TIME:
// 1695     default:
// 1696       stat = ZFailure;
// 1697       break;
// 1698   }
// 1699 
// 1700   return ( stat );
??zclGeneral_HdlInSpecificCommands_6:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
// 1701 }
          CFI EndBlock cfiBlock2

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine1:
          CFI Block cfiCond3 Using cfiCommon0
          CFI Function zclGeneral_HdlInSpecificCommands
          CFI Conditional ??CrossCallReturnLabel_3
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond4 Using cfiCommon0
          CFI (cfiCond4) Function zclGeneral_HdlInSpecificCommands
          CFI (cfiCond4) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond4) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond4) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond4) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond4) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond4) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond4) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond4) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond4) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond4) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond4) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond4) CFA_SP SP+-2
          CFI (cfiCond4) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function zclGeneral_HdlInSpecificCommands
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond5) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond5) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond5) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond5) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond5) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond5) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond5) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond5) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond5) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond5) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond5) CFA_SP SP+-2
          CFI (cfiCond5) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiPicker6 Using cfiCommon1
          CFI (cfiPicker6) NoFunction
          CFI (cfiPicker6) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        RET
          CFI EndBlock cfiCond3
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiPicker6

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
?Subroutine0:
          CFI Block cfiCond7 Using cfiCommon0
          CFI Function zclGeneral_HdlInSpecificCommands
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI CFA_SP SP+-2
          CFI CFA_XSP16 add(XSP16, 10)
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function zclGeneral_HdlInSpecificCommands
          CFI (cfiCond8) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond8) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI (cfiCond8) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI (cfiCond8) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI (cfiCond8) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI (cfiCond8) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI (cfiCond8) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI (cfiCond8) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI (cfiCond8) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI (cfiCond8) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI (cfiCond8) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI (cfiCond8) CFA_SP SP+-2
          CFI (cfiCond8) CFA_XSP16 add(XSP16, 10)
          CFI Block cfiPicker9 Using cfiCommon1
          CFI (cfiPicker9) NoFunction
          CFI (cfiPicker9) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        MOV     A,DPL
        ORL     A,DPH
        RET
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiPicker9

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??zclGeneral_RegisterCmdCallbacks::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGeneral_RegisterCmdCallbacks

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??zclGeneral_HdlIncoming::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGeneral_HdlIncoming

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??zclGeneral_HdlInSpecificCommands::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    zclGeneral_HdlInSpecificCommands

        END
// 1702 
// 1703 #ifdef ZCL_BASIC
// 1704 /*********************************************************************
// 1705  * @fn      zclGeneral_ProcessInBasic
// 1706  *
// 1707  * @brief   Process in the received Basic Command.
// 1708  *
// 1709  * @param   pInMsg - pointer to the incoming message
// 1710  *
// 1711  * @return  ZStatus_t
// 1712  */
// 1713 static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
// 1714                                             zclGeneral_AppCallbacks_t *pCBs )
// 1715 {
// 1716   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1717   {
// 1718     if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
// 1719       return ( ZFailure );   // Error ignore the command
// 1720 
// 1721     if ( pCBs->pfnBasicReset )
// 1722       pCBs->pfnBasicReset();
// 1723   }
// 1724   // no Client command
// 1725 
// 1726   return ( ZSuccess );
// 1727 }
// 1728 #endif // ZCL_BASIC
// 1729 
// 1730 #ifdef ZCL_IDENTIFY
// 1731 /*********************************************************************
// 1732  * @fn      zclGeneral_ProcessInIdentity
// 1733  *
// 1734  * @brief   Process in the received Identity Command.
// 1735  *
// 1736  * @param   pInMsg - pointer to the incoming message
// 1737  *
// 1738  * @return  ZStatus_t
// 1739  */
// 1740 static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
// 1741                                                zclGeneral_AppCallbacks_t *pCBs )
// 1742 {
// 1743   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1744   {
// 1745     if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
// 1746     {
// 1747       if ( pCBs->pfnIdentify )
// 1748       {
// 1749         zclIdentify_t cmd;
// 1750 
// 1751         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1752         cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1753 
// 1754         pCBs->pfnIdentify( &cmd );
// 1755       }
// 1756     }
// 1757     else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_QUERY )
// 1758     {
// 1759       uint16 identifyTime = 0;
// 1760 
// 1761       // Retrieve Identify Time
// 1762       zcl_ReadAttrData( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
// 1763                         ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
// 1764 
// 1765       // Is device identifying itself?
// 1766       if ( identifyTime > 0 )
// 1767       {
// 1768         zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1769                                               identifyTime, true, pInMsg->hdr.transSeqNum );
// 1770 #ifdef ZCL_EZMODE
// 1771         zcl_EZModeAction( EZMODE_ACTION_IDENTIFY_QUERY, NULL );
// 1772 #endif
// 1773         return ( ZCL_STATUS_CMD_HAS_RSP );
// 1774       }
// 1775     }
// 1776 #ifdef ZCL_EZMODE
// 1777     else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_EZMODE_INVOKE )
// 1778     {
// 1779       if ( pCBs->pfnIdentifyEZModeInvoke )
// 1780       {
// 1781         pCBs->pfnIdentifyEZModeInvoke( pInMsg->pData[0] );
// 1782       }
// 1783     }
// 1784     else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_UPDATE_COMMISSION_STATE )
// 1785     {
// 1786       if ( pCBs->pfnIdentifyUpdateCommState )
// 1787       {
// 1788         zclIdentifyUpdateCommState_t cmd;
// 1789 
// 1790         cmd.action = pInMsg->pData[0];
// 1791         cmd.commissionStateMask = pInMsg->pData[1];
// 1792 
// 1793         pCBs->pfnIdentifyUpdateCommState( &cmd );
// 1794       }
// 1795     }
// 1796 #endif
// 1797 
// 1798 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 1799     else if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY_TRIGGER_EFFECT )
// 1800     {
// 1801       if ( pCBs->pfnIdentifyTriggerEffect )
// 1802       {
// 1803         zclIdentifyTriggerEffect_t cmd;
// 1804 
// 1805         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 1806         cmd.effectId = pInMsg->pData[0];
// 1807         cmd.effectVariant = pInMsg->pData[1];
// 1808 
// 1809         pCBs->pfnIdentifyTriggerEffect( &cmd );
// 1810       }
// 1811     }
// 1812 #endif //ZCL_LIGHT_LINK_ENHANCE
// 1813     else
// 1814     {
// 1815       return ( ZFailure );   // Error ignore the command
// 1816     }
// 1817   }
// 1818   else // Client Command
// 1819   {
// 1820     if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
// 1821       return ( ZFailure );   // Error ignore the command
// 1822 
// 1823     if ( pCBs->pfnIdentifyQueryRsp )
// 1824     {
// 1825       zclIdentifyQueryRsp_t rsp;
// 1826 
// 1827       rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 1828       rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
// 1829 
// 1830       pCBs->pfnIdentifyQueryRsp( &rsp );
// 1831     }
// 1832   }
// 1833 
// 1834   return ( ZSuccess );
// 1835 }
// 1836 #endif // ZCL_IDENTIFY
// 1837 
// 1838 #ifdef ZCL_GROUPS
// 1839 
// 1840 /*********************************************************************
// 1841  * @fn      zclGeneral_AddGroup
// 1842  *
// 1843  * @brief   Add a Group.
// 1844  *
// 1845  * @param   endPoint - application endpoint
// 1846  * @param   group - group to be added
// 1847  * @param   pData - pointer to the group info
// 1848  *
// 1849  * @return  ZStatus_t
// 1850  */
// 1851 static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
// 1852 {
// 1853   uint8 nameLen;
// 1854   uint8 nameSupport = FALSE;
// 1855 
// 1856   pData += 2;   // Move past group ID
// 1857   nameLen = *pData++;
// 1858 
// 1859   // Retrieve Name Support attribute
// 1860   zcl_ReadAttrData( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS,
// 1861                     ATTRID_GROUP_NAME_SUPPORT, &nameSupport, NULL );
// 1862 
// 1863   if ( nameSupport )
// 1864   {
// 1865     if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 1866        nameLen = (APS_GROUP_NAME_LEN-1);
// 1867     group->name[0] = nameLen;
// 1868     zcl_memcpy( &(group->name[1]), pData, nameLen );
// 1869   }
// 1870 
// 1871   return ( aps_AddGroup( endPoint, group ) );
// 1872 }
// 1873 
// 1874 /*********************************************************************
// 1875  * @fn      zclGeneral_ProcessInGroupsServer
// 1876  *
// 1877  * @brief   Process in the received Groups Command.
// 1878  *
// 1879  * @param   pInMsg - pointer to the incoming message
// 1880  *
// 1881  * @return  ZStatus_t
// 1882  */
// 1883 static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
// 1884 {
// 1885   aps_Group_t group;
// 1886   aps_Group_t *pGroup;
// 1887   uint8 *pData;
// 1888   uint8 status;
// 1889   uint8 grpCnt;
// 1890   uint8 grpRspCnt = 0;
// 1891   uint16 *grpList;
// 1892   uint16 identifyTime = 0;
// 1893   uint8 i;
// 1894   ZStatus_t stat = ZSuccess;
// 1895 
// 1896   zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 1897 
// 1898   pData = pInMsg->pData;
// 1899   group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1900   switch ( pInMsg->hdr.commandID )
// 1901   {
// 1902     case COMMAND_GROUP_ADD:
// 1903       status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 1904       if ( status != ZSuccess )
// 1905       {
// 1906         if ( status == ZApsDuplicateEntry )
// 1907         {
// 1908           status = ZCL_STATUS_DUPLICATE_EXISTS;
// 1909         }
// 1910         else
// 1911         {
// 1912           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1913         }
// 1914       }
// 1915 #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
// 1916       if ( UNICAST_MSG( pInMsg->msg ) )
// 1917 #endif
// 1918       {
// 1919         zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1920                                          status, group.ID, true, pInMsg->hdr.transSeqNum );
// 1921         stat = ZCL_STATUS_CMD_HAS_RSP;
// 1922       }
// 1923       break;
// 1924 
// 1925     case COMMAND_GROUP_VIEW:
// 1926 #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
// 1927       if ( UNICAST_MSG( pInMsg->msg ) )
// 1928 #endif
// 1929       {
// 1930         pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
// 1931         if ( pGroup )
// 1932         {
// 1933           status = ZCL_STATUS_SUCCESS;
// 1934         }
// 1935         else
// 1936         {
// 1937           // Group not found
// 1938           status = ZCL_STATUS_NOT_FOUND;
// 1939           pGroup = &group;
// 1940         }
// 1941         zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1942                                           status, pGroup, true, pInMsg->hdr.transSeqNum );
// 1943         stat = ZCL_STATUS_CMD_HAS_RSP;
// 1944       }
// 1945       break;
// 1946 
// 1947     case COMMAND_GROUP_GET_MEMBERSHIP:
// 1948 #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
// 1949       if ( UNICAST_MSG( pInMsg->msg ) )
// 1950 #endif
// 1951       {
// 1952         grpCnt = *pData++;
// 1953 
// 1954         // Allocate space for the group list
// 1955         grpList = zcl_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
// 1956         if ( grpList != NULL )
// 1957         {
// 1958           if ( grpCnt == 0 )
// 1959           {
// 1960             // Find out all the groups of which the endpoint is a member.
// 1961             grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
// 1962           }
// 1963           else
// 1964           {
// 1965             // Find out the groups (in the list) of which the endpoint is a member.
// 1966             for ( i = 0; i < grpCnt; i++ )
// 1967             {
// 1968               group.ID = BUILD_UINT16( pData[0], pData[1] );
// 1969               pData += 2;
// 1970 
// 1971               if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
// 1972                 grpList[grpRspCnt++] = group.ID;
// 1973             }
// 1974           }
// 1975 
// 1976           if ( grpCnt == 0 ||  grpRspCnt != 0 )
// 1977           {
// 1978             zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 1979                                                        aps_GroupsRemaingCapacity(), grpRspCnt,
// 1980                                                        grpList, true, pInMsg->hdr.transSeqNum );
// 1981           }
// 1982 
// 1983           zcl_mem_free( grpList );
// 1984         }
// 1985         else
// 1986         {
// 1987           // Couldn't allocate space for the group list -- send a Default Response command back.
// 1988           zclDefaultRspCmd_t defaultRspCmd;
// 1989 
// 1990           defaultRspCmd.commandID = pInMsg->hdr.commandID;
// 1991           defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
// 1992           zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 1993                                  pInMsg->msg->clusterId, &defaultRspCmd,
// 1994                                  ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
// 1995         }
// 1996 
// 1997         stat = ZCL_STATUS_CMD_HAS_RSP;
// 1998       }
// 1999       break;
// 2000 
// 2001     case COMMAND_GROUP_REMOVE:
// 2002 #if defined ( ZCL_SCENES )
// 2003       zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, group.ID );
// 2004 #endif
// 2005       if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
// 2006       {
// 2007         status = ZCL_STATUS_SUCCESS;
// 2008       }
// 2009       else
// 2010       {
// 2011         status = ZCL_STATUS_NOT_FOUND;
// 2012       }
// 2013 
// 2014 #if defined( ZCL_LIGHT_LINK_ENHANCE ) //ZLL allows response to unicast only
// 2015       if ( UNICAST_MSG( pInMsg->msg ) )
// 2016 #endif
// 2017       {
// 2018         zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2019                                             status, group.ID, true, pInMsg->hdr.transSeqNum );
// 2020         stat = ZCL_STATUS_CMD_HAS_RSP;
// 2021       }
// 2022       break;
// 2023 
// 2024     case COMMAND_GROUP_REMOVE_ALL:
// 2025       {
// 2026         uint8 numGroups;
// 2027         uint16 groupList[APS_MAX_GROUPS];
// 2028 
// 2029         if ( numGroups = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, groupList ) )
// 2030         {
// 2031           for ( i = 0; i < numGroups; i++ )
// 2032           {
// 2033 #if defined ( ZCL_SCENES )
// 2034             zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, groupList[i] );
// 2035 #endif
// 2036           }
// 2037 
// 2038           aps_RemoveAllGroup( pInMsg->msg->endPoint );
// 2039         }
// 2040       }
// 2041       break;
// 2042 
// 2043     case COMMAND_GROUP_ADD_IF_IDENTIFYING:
// 2044       // Retrieve Identify Time
// 2045       zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
// 2046                         ATTRID_IDENTIFY_TIME, (uint8 *)&identifyTime, NULL );
// 2047 
// 2048       // Is device identifying itself?
// 2049       if ( identifyTime > 0 )
// 2050       {
// 2051         zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
// 2052       }
// 2053       break;
// 2054 
// 2055     default:
// 2056       stat = ZFailure;
// 2057       break;
// 2058   }
// 2059 
// 2060   return ( stat );
// 2061 }
// 2062 
// 2063 /*********************************************************************
// 2064  * @fn      zclGeneral_ProcessInGroupsClient
// 2065  *
// 2066  * @brief   Process in the received Groups Command.
// 2067  *
// 2068  * @param   pInMsg - pointer to the incoming message
// 2069  *
// 2070  * @return  ZStatus_t
// 2071  */
// 2072 static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
// 2073                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2074 {
// 2075   aps_Group_t group;
// 2076   uint8 *pData = pInMsg->pData;
// 2077   uint8 grpCnt;
// 2078   uint8 nameLen;
// 2079   zclGroupRsp_t rsp;
// 2080   uint8 i;
// 2081   ZStatus_t stat = ZSuccess;
// 2082 
// 2083   zcl_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
// 2084   zcl_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
// 2085 
// 2086   switch ( pInMsg->hdr.commandID )
// 2087   {
// 2088     case COMMAND_GROUP_ADD_RSP:
// 2089     case COMMAND_GROUP_VIEW_RSP:
// 2090     case COMMAND_GROUP_REMOVE_RSP:
// 2091       rsp.status = *pData++;
// 2092       group.ID = BUILD_UINT16( pData[0], pData[1] );
// 2093 
// 2094       if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
// 2095       {
// 2096         pData += 2;   // Move past ID
// 2097         nameLen = *pData++;
// 2098         if ( nameLen > (APS_GROUP_NAME_LEN-1) )
// 2099           nameLen = (APS_GROUP_NAME_LEN-1);
// 2100         group.name[0] = nameLen;
// 2101         zcl_memcpy( &(group.name[1]), pData, nameLen );
// 2102         rsp.grpName = group.name;
// 2103       }
// 2104 
// 2105       if ( pCBs->pfnGroupRsp )
// 2106       {
// 2107         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2108         rsp.cmdID = pInMsg->hdr.commandID;
// 2109         rsp.grpCnt = 1;
// 2110         rsp.grpList = &group.ID;
// 2111         rsp.capacity = 0;
// 2112 
// 2113         pCBs->pfnGroupRsp( &rsp );
// 2114       }
// 2115       break;
// 2116 
// 2117     case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
// 2118       {
// 2119         uint16 *grpList = NULL;
// 2120         rsp.capacity = *pData++;
// 2121         grpCnt = *pData++;
// 2122 
// 2123         if ( grpCnt > 0 )
// 2124         {
// 2125           // Allocate space for the group list
// 2126           grpList = zcl_mem_alloc( sizeof( uint16 ) * grpCnt );
// 2127           if ( grpList != NULL )
// 2128           {
// 2129             rsp.grpCnt = grpCnt;
// 2130             for ( i = 0; i < grpCnt; i++ )
// 2131             {
// 2132               grpList[i] = BUILD_UINT16( pData[0], pData[1] );
// 2133               pData += 2;
// 2134             }
// 2135           }
// 2136         }
// 2137 
// 2138         if ( pCBs->pfnGroupRsp )
// 2139         {
// 2140           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 2141           rsp.cmdID = pInMsg->hdr.commandID;
// 2142           rsp.grpList = grpList;
// 2143 
// 2144           pCBs->pfnGroupRsp( &rsp );
// 2145         }
// 2146 
// 2147         if ( grpList != NULL )
// 2148         {
// 2149           zcl_mem_free( grpList );
// 2150         }
// 2151       }
// 2152       break;
// 2153 
// 2154     default:
// 2155       stat = ZFailure;
// 2156       break;
// 2157   }
// 2158 
// 2159   return ( stat );
// 2160 }
// 2161 #endif // ZCL_GROUPS
// 2162 
// 2163 #if defined( ZCL_SCENES )
// 2164 #if !defined ( ZCL_STANDALONE )
// 2165 /*********************************************************************
// 2166  * @fn      zclGeneral_AddScene
// 2167  *
// 2168  * @brief   Add a scene for an endpoint
// 2169  *
// 2170  * @param   endpoint -
// 2171  * @param   scene - new scene item
// 2172  *
// 2173  * @return  ZStatus_t
// 2174  */
// 2175 ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
// 2176 {
// 2177   zclGenSceneItem_t *pNewItem;
// 2178   zclGenSceneItem_t *pLoop;
// 2179 
// 2180   // Fill in the new profile list
// 2181   pNewItem = zcl_mem_alloc( sizeof( zclGenSceneItem_t ) );
// 2182   if ( pNewItem == NULL )
// 2183     return ( ZMemError );
// 2184 
// 2185   // Fill in the plugin record.
// 2186   pNewItem->next = (zclGenSceneItem_t *)NULL;
// 2187   pNewItem->endpoint = endpoint;
// 2188   zcl_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
// 2189 
// 2190   // Find spot in list
// 2191   if (  zclGenSceneTable == NULL )
// 2192   {
// 2193     zclGenSceneTable = pNewItem;
// 2194   }
// 2195   else
// 2196   {
// 2197     // Look for end of list
// 2198     pLoop = zclGenSceneTable;
// 2199     while ( pLoop->next != NULL )
// 2200       pLoop = pLoop->next;
// 2201 
// 2202     // Put new item at end of list
// 2203     pLoop->next = pNewItem;
// 2204   }
// 2205 
// 2206   // Update NV
// 2207   zclGeneral_ScenesWriteNV();
// 2208 
// 2209   return ( ZSuccess );
// 2210 }
// 2211 #endif // ZCL_STANDALONE
// 2212 
// 2213 #if !defined ( ZCL_STANDALONE )
// 2214 /*********************************************************************
// 2215  * @fn      zclGeneral_FindScene
// 2216  *
// 2217  * @brief   Find a scene with endpoint and sceneID
// 2218  *
// 2219  * @param   endpoint -
// 2220  * @param   groupID - what group the scene belongs to
// 2221  * @param   sceneID - ID to look for scene
// 2222  *
// 2223  * @return  a pointer to the scene information, NULL if not found
// 2224  */
// 2225 zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 2226 {
// 2227   zclGenSceneItem_t *pLoop;
// 2228 
// 2229   // Look for end of list
// 2230   pLoop = zclGenSceneTable;
// 2231   while ( pLoop )
// 2232   {
// 2233     if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
// 2234         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 2235     {
// 2236       return ( &(pLoop->scene) );
// 2237     }
// 2238     pLoop = pLoop->next;
// 2239   }
// 2240 
// 2241   return ( (zclGeneral_Scene_t *)NULL );
// 2242 }
// 2243 #endif // ZCL_STANDALONE
// 2244 
// 2245 #if !defined ( ZCL_STANDALONE )
// 2246 /*********************************************************************
// 2247  * @fn      zclGeneral_FindAllScenesForGroup
// 2248  *
// 2249  * @brief   Find all the scenes with groupID
// 2250  *
// 2251  * @param   endpoint - endpoint to look for
// 2252  * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
// 2253  *
// 2254  * @return  number of scenes copied to sceneList
// 2255  */
// 2256 uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
// 2257 {
// 2258   zclGenSceneItem_t *pLoop;
// 2259   uint8 cnt = 0;
// 2260 
// 2261   // Look for end of list
// 2262   pLoop = zclGenSceneTable;
// 2263   while ( pLoop )
// 2264   {
// 2265     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 2266       sceneList[cnt++] = pLoop->scene.ID;
// 2267     pLoop = pLoop->next;
// 2268   }
// 2269   return ( cnt );
// 2270 }
// 2271 #endif // ZCL_STANDALONE
// 2272 
// 2273 #if !defined ( ZCL_STANDALONE )
// 2274 /*********************************************************************
// 2275  * @fn      zclGeneral_RemoveScene
// 2276  *
// 2277  * @brief   Remove a scene with endpoint and sceneID
// 2278  *
// 2279  * @param   endpoint -
// 2280  * @param   groupID - what group the scene belongs to
// 2281  * @param   sceneID - ID to look for scene
// 2282  *
// 2283  * @return  TRUE if removed, FALSE if not found
// 2284  */
// 2285 uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
// 2286 {
// 2287   zclGenSceneItem_t *pLoop;
// 2288   zclGenSceneItem_t *pPrev;
// 2289 
// 2290   // Look for end of list
// 2291   pLoop = zclGenSceneTable;
// 2292   pPrev = NULL;
// 2293   while ( pLoop )
// 2294   {
// 2295     if ( pLoop->endpoint == endpoint
// 2296         && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
// 2297     {
// 2298       if ( pPrev == NULL )
// 2299         zclGenSceneTable = pLoop->next;
// 2300       else
// 2301         pPrev->next = pLoop->next;
// 2302 
// 2303       // Free the memory
// 2304       zcl_mem_free( pLoop );
// 2305 
// 2306       // Update NV
// 2307       zclGeneral_ScenesWriteNV();
// 2308 
// 2309       return ( TRUE );
// 2310     }
// 2311     pPrev = pLoop;
// 2312     pLoop = pLoop->next;
// 2313   }
// 2314 
// 2315   return ( FALSE );
// 2316 }
// 2317 #endif // ZCL_STANDALONE
// 2318 
// 2319 #if !defined ( ZCL_STANDALONE )
// 2320 /*********************************************************************
// 2321  * @fn      zclGeneral_RemoveAllScenes
// 2322  *
// 2323  * @brief   Remove all scenes with endpoint and group Id
// 2324  *
// 2325  * @param   endpoint -
// 2326  * @param   groupID - ID to look for group
// 2327  *
// 2328  * @return  none
// 2329  */
// 2330 void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
// 2331 {
// 2332   zclGenSceneItem_t *pLoop;
// 2333   zclGenSceneItem_t *pPrev;
// 2334   zclGenSceneItem_t *pNext;
// 2335 
// 2336   // Look for end of list
// 2337   pLoop = zclGenSceneTable;
// 2338   pPrev = NULL;
// 2339   while ( pLoop )
// 2340   {
// 2341     if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
// 2342     {
// 2343       if ( pPrev == NULL )
// 2344         zclGenSceneTable = pLoop->next;
// 2345       else
// 2346         pPrev->next = pLoop->next;
// 2347       pNext = pLoop->next;
// 2348 
// 2349       // Free the memory
// 2350       zcl_mem_free( pLoop );
// 2351       pLoop = pNext;
// 2352     }
// 2353     else
// 2354     {
// 2355       pPrev = pLoop;
// 2356       pLoop = pLoop->next;
// 2357     }
// 2358   }
// 2359 
// 2360   // Update NV
// 2361   zclGeneral_ScenesWriteNV();
// 2362 }
// 2363 #endif // ZCL_STANDALONE
// 2364 
// 2365 #if !defined ( ZCL_STANDALONE )
// 2366 /*********************************************************************
// 2367  * @fn      zclGeneral_CountScenes
// 2368  *
// 2369  * @brief   Count the number of scenes for an endpoint
// 2370  *
// 2371  * @param   endpoint -
// 2372  *
// 2373  * @return  number of scenes assigned to an endpoint
// 2374  */
// 2375 uint8 zclGeneral_CountScenes( uint8 endpoint )
// 2376 {
// 2377   zclGenSceneItem_t *pLoop;
// 2378   uint8 cnt = 0;
// 2379 
// 2380   // Look for end of list
// 2381   pLoop = zclGenSceneTable;
// 2382   while ( pLoop )
// 2383   {
// 2384     if ( pLoop->endpoint == endpoint  )
// 2385       cnt++;
// 2386     pLoop = pLoop->next;
// 2387   }
// 2388   return ( cnt );
// 2389 }
// 2390 #endif
// 2391 
// 2392 #if !defined ( ZCL_STANDALONE )
// 2393 /*********************************************************************
// 2394  * @fn      zclGeneral_CountAllScenes
// 2395  *
// 2396  * @brief   Count the total number of scenes
// 2397  *
// 2398  * @param   none
// 2399  *
// 2400  * @return  number of scenes
// 2401  */
// 2402 uint8 zclGeneral_CountAllScenes( void )
// 2403 {
// 2404   zclGenSceneItem_t *pLoop;
// 2405   uint8 cnt = 0;
// 2406 
// 2407   // Look for end of list
// 2408   pLoop = zclGenSceneTable;
// 2409   while ( pLoop )
// 2410   {
// 2411     cnt++;
// 2412     pLoop = pLoop->next;
// 2413   }
// 2414   return ( cnt );
// 2415 }
// 2416 #endif // ZCL_STANDALONE
// 2417 
// 2418 /*********************************************************************
// 2419  * @fn      zclGeneral_ReadSceneCountCB
// 2420  *
// 2421  * @brief   Read the number of scenes currently in the device's
// 2422  *          scene table (i.e., the Scene Count attribute).
// 2423  *
// 2424  *          Note: This function gets called only when the pointer
// 2425  *                'dataPtr' to the Scene Count attribute value is
// 2426  *                NULL in the attribute database registered with
// 2427  *                the ZCL.
// 2428  *
// 2429  * @param   clusterId - cluster that attribute belongs to
// 2430  * @param   attrId - attribute to be read or written
// 2431  * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ, or ZCL_OPER_WRITE
// 2432  * @param   pValue - pointer to attribute value
// 2433  * @param   pLen - pointer to length of attribute value read
// 2434  *
// 2435  * @return  status
// 2436  */
// 2437 ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
// 2438                                        uint8 oper, uint8 *pValue, uint16 *pLen )
// 2439 {
// 2440   ZStatus_t status = ZCL_STATUS_SUCCESS;
// 2441 
// 2442   // This callback function should only be called for the Scene Count attribute
// 2443   switch ( oper )
// 2444   {
// 2445     case ZCL_OPER_LEN:
// 2446       *pLen = 1; // uint8
// 2447       break;
// 2448 
// 2449     case ZCL_OPER_READ:
// 2450       *pValue = zclGeneral_CountAllScenes();
// 2451 
// 2452       if ( pLen != NULL )
// 2453       {
// 2454         *pLen = 1;
// 2455       }
// 2456       break;
// 2457 
// 2458     case ZCL_OPER_WRITE:
// 2459       // Fall through
// 2460 
// 2461     default:
// 2462       status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
// 2463       break;
// 2464   }
// 2465 
// 2466   return ( status );
// 2467 }
// 2468 
// 2469 /*********************************************************************
// 2470  * @fn      zclGeneral_ProcessInScenesServer
// 2471  *
// 2472  * @brief   Process in the received Scenes Command.
// 2473  *
// 2474  * @param   pInMsg - pointer to the incoming message
// 2475  *
// 2476  * @return  ZStatus_t
// 2477  */
// 2478 static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
// 2479                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2480 {
// 2481   zclGeneral_Scene_t scene;
// 2482   zclGeneral_Scene_t *pScene;
// 2483   uint8 *pData = pInMsg->pData;
// 2484   uint8 nameLen;
// 2485   uint8 status;
// 2486   uint8 sceneCnt = 0;
// 2487   uint8 *sceneList = NULL;
// 2488   uint8 sendRsp = TRUE;
// 2489   uint8 nameSupport = FALSE;
// 2490   ZStatus_t stat = ZSuccess;
// 2491 
// 2492   zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2493 
// 2494   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2495   pData += 2;   // Move past group ID
// 2496   scene.ID = *pData++;
// 2497 
// 2498   switch ( pInMsg->hdr.commandID )
// 2499   {
// 2500     case COMMAND_SCENE_ADD:
// 2501 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 2502     case COMMAND_SCENE_ENHANCED_ADD:
// 2503 #endif // ZCL_LIGHT_LINK_ENHANCE
// 2504       // Parse the rest of the incoming message
// 2505       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2506       pData += 2;
// 2507 
// 2508       if ( pInMsg->hdr.commandID == COMMAND_SCENE_ENHANCED_ADD )
// 2509       {
// 2510         // Received transition time is in 1/10 second
// 2511         scene.transTime100ms = scene.transTime % 10;
// 2512         scene.transTime /= 10;
// 2513       }
// 2514 
// 2515       nameLen= *pData++; // Name length
// 2516 
// 2517       // Retrieve Name Support attribute
// 2518       zcl_ReadAttrData( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES,
// 2519                         ATTRID_SCENES_NAME_SUPPORT, &nameSupport, NULL );
// 2520 
// 2521       if ( nameSupport )
// 2522       {
// 2523         if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2524           nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 2525         scene.name[0] = nameLen;
// 2526         zcl_memcpy( &(scene.name[1]), pData, nameLen );
// 2527       }
// 2528 
// 2529       pData += nameLen; // move past name, use original length
// 2530 
// 2531       scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
// 2532       if ( scene.extLen > 0 )
// 2533       {
// 2534         // Copy the extention field(s)
// 2535         if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
// 2536         {
// 2537           scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
// 2538         }
// 2539         zcl_memcpy( scene.extField, pData, scene.extLen );
// 2540       }
// 2541 
// 2542       if ( scene.groupID == 0x0000 ||
// 2543            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2544       {
// 2545         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2546         // does and the corresponding Group exits
// 2547         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2548         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2549         {
// 2550           status = ZCL_STATUS_SUCCESS;
// 2551           if ( pScene != NULL )
// 2552           {
// 2553             // The Scene already exists so update it
// 2554             pScene->transTime = scene.transTime;
// 2555             zcl_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
// 2556 
// 2557             // Use the new extention field(s)
// 2558             zcl_memcpy( pScene->extField, scene.extField, scene.extLen );
// 2559             pScene->extLen = scene.extLen;
// 2560 
// 2561             // Save Scenes
// 2562             zclGeneral_ScenesSave();
// 2563           }
// 2564           else
// 2565           {
// 2566             // The Scene doesn't exist so add it
// 2567             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2568           }
// 2569         }
// 2570         else
// 2571         {
// 2572           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2573         }
// 2574       }
// 2575       else
// 2576       {
// 2577         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2578       }
// 2579 
// 2580       if ( UNICAST_MSG( pInMsg->msg ) )
// 2581       {
// 2582         if ( pInMsg->hdr.commandID == COMMAND_SCENE_ADD )
// 2583         {
// 2584           zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2585                                           status, scene.groupID, scene.ID,
// 2586                                           true, pInMsg->hdr.transSeqNum );
// 2587         }
// 2588 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 2589         else // COMMAND_SCENE_ENHANCED_ADD
// 2590         {
// 2591           zclGeneral_SendSceneEnhancedAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2592                                                   status, scene.groupID, scene.ID,
// 2593                                                   true, pInMsg->hdr.transSeqNum );
// 2594         }
// 2595 #endif // ZCL_LIGHT_LINK_ENHANCE
// 2596       }
// 2597       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2598 
// 2599       break;
// 2600 
// 2601     case COMMAND_SCENE_VIEW:
// 2602 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 2603     case COMMAND_SCENE_ENHANCED_VIEW:
// 2604 #endif // ZCL_LIGHT_LINK_ENHANCE
// 2605       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2606       if ( pScene != NULL )
// 2607       {
// 2608         status = ZCL_STATUS_SUCCESS;
// 2609       }
// 2610       else
// 2611       {
// 2612         // Scene not found
// 2613         if ( scene.groupID != 0x0000 &&
// 2614              aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2615         {
// 2616           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2617         }
// 2618         else
// 2619         {
// 2620           status = ZCL_STATUS_NOT_FOUND;
// 2621         }
// 2622         pScene = &scene;
// 2623       }
// 2624 
// 2625       if ( UNICAST_MSG( pInMsg->msg ) )
// 2626       {
// 2627         if ( pInMsg->hdr.commandID == COMMAND_SCENE_VIEW )
// 2628         {
// 2629           zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2630                                            status, pScene, true, pInMsg->hdr.transSeqNum );
// 2631         }
// 2632 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 2633         else
// 2634         {
// 2635           zclGeneral_SendSceneEnhancedViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2636                                                    status, pScene, true, pInMsg->hdr.transSeqNum );
// 2637         }
// 2638 #endif // ZCL_LIGHT_LINK_ENHANCE
// 2639       }
// 2640       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2641       break;
// 2642 
// 2643     case COMMAND_SCENE_REMOVE:
// 2644       if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
// 2645       {
// 2646         status = ZCL_STATUS_SUCCESS;
// 2647       }
// 2648       else
// 2649       {
// 2650         // Scene not found
// 2651         if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
// 2652         {
// 2653           // The Group is not in the Group Table
// 2654           status = ZCL_STATUS_INVALID_FIELD;
// 2655         }
// 2656         else
// 2657         {
// 2658           status = ZCL_STATUS_NOT_FOUND;
// 2659         }
// 2660       }
// 2661 
// 2662       if ( UNICAST_MSG( pInMsg->msg ) )
// 2663       {
// 2664         // Addressed to this device (not to a group) - send a response back
// 2665         zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2666                                             status, scene.groupID,
// 2667                                             scene.ID, true, pInMsg->hdr.transSeqNum );
// 2668       }
// 2669       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2670       break;
// 2671 
// 2672     case COMMAND_SCENE_REMOVE_ALL:
// 2673       if ( scene.groupID == 0x0000 ||
// 2674            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2675       {
// 2676         zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
// 2677         status = ZCL_STATUS_SUCCESS;
// 2678       }
// 2679       else
// 2680       {
// 2681         status = ZCL_STATUS_INVALID_FIELD;
// 2682       }
// 2683 
// 2684       if ( UNICAST_MSG( pInMsg->msg ) )
// 2685       {
// 2686         // Addressed to this device (not to a group) - send a response back
// 2687         zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2688                                                status, scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2689       }
// 2690       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2691       break;
// 2692 
// 2693     case COMMAND_SCENE_STORE:
// 2694       if ( scene.groupID == 0x0000 ||
// 2695            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2696       {
// 2697         // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
// 2698         // does and the corresponding Group exits
// 2699         pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2700         if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
// 2701         {
// 2702           uint8 sceneChanged = FALSE;
// 2703 
// 2704           status = ZCL_STATUS_SUCCESS;
// 2705           if ( pScene == NULL )
// 2706           {
// 2707             // Haven't been added yet
// 2708             pScene = &scene;
// 2709           }
// 2710 
// 2711           if ( pCBs->pfnSceneStoreReq )
// 2712           {
// 2713             zclSceneReq_t req;
// 2714 
// 2715             req.srcAddr = &(pInMsg->msg->srcAddr);
// 2716             req.scene = pScene;
// 2717 
// 2718             // Get the latest Scene info
// 2719             if ( pCBs->pfnSceneStoreReq( &req ) )
// 2720             {
// 2721               sceneChanged = TRUE;
// 2722             }
// 2723           }
// 2724 
// 2725           if ( pScene == &scene )
// 2726           {
// 2727             // The Scene doesn't exist so add it
// 2728             zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2729           }
// 2730           else if ( sceneChanged )
// 2731           {
// 2732             // The Scene already exists so update only NV
// 2733             zclGeneral_ScenesSave();
// 2734           }
// 2735         }
// 2736         else
// 2737         {
// 2738           status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2739         }
// 2740       }
// 2741       else
// 2742       {
// 2743         status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2744       }
// 2745 
// 2746       if ( UNICAST_MSG( pInMsg->msg ) )
// 2747       {
// 2748         // Addressed to this device (not to a group) - send a response back
// 2749         zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2750                                            status, scene.groupID, scene.ID,
// 2751                                            true, pInMsg->hdr.transSeqNum );
// 2752       }
// 2753       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2754       break;
// 2755 
// 2756     case COMMAND_SCENE_RECALL:
// 2757       pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
// 2758       if ( pScene && pCBs->pfnSceneRecallReq )
// 2759       {
// 2760         zclSceneReq_t req;
// 2761 
// 2762         req.srcAddr = &(pInMsg->msg->srcAddr);
// 2763         req.scene = pScene;
// 2764 
// 2765         pCBs->pfnSceneRecallReq( &req );
// 2766       }
// 2767       // No response
// 2768       break;
// 2769 
// 2770     case COMMAND_SCENE_GET_MEMBERSHIP:
// 2771       // Find all the Scenes corresponding to the Group ID
// 2772       if ( scene.groupID == 0x0000 ||
// 2773            aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
// 2774       {
// 2775         // Allocate space for the scene list
// 2776         sceneList = zcl_mem_alloc( ZCL_GEN_MAX_SCENES );
// 2777         if ( sceneList != NULL )
// 2778         {
// 2779           sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
// 2780                                                        scene.groupID, sceneList );
// 2781           status = ZCL_STATUS_SUCCESS;
// 2782           if ( ! UNICAST_MSG( pInMsg->msg ) )
// 2783           {
// 2784             // Addressed to the Group - ONLY send a response if an entry within the
// 2785             // Scene Table corresponds to the Group ID
// 2786             if ( sceneCnt == 0 )
// 2787             {
// 2788               sendRsp = FALSE;
// 2789             }
// 2790           }
// 2791         }
// 2792         else
// 2793         {
// 2794           // Couldn't allocate space for the scene list!
// 2795           status = ZCL_STATUS_INSUFFICIENT_SPACE;
// 2796         }
// 2797       }
// 2798       else
// 2799       {
// 2800         // The Group is not in the Group Table - send a response back
// 2801         status = ZCL_STATUS_INVALID_FIELD;
// 2802       }
// 2803 
// 2804 #ifdef ZCL_LIGHT_LINK_ENHANCE //ZLL allows response to unicast only
// 2805       if ( sendRsp && UNICAST_MSG( pInMsg->msg ) )
// 2806 #else
// 2807       if ( sendRsp )
// 2808 #endif //ZCL_LIGHT_LINK_ENHANCE
// 2809       {
// 2810         zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2811                                     status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
// 2812                                     scene.groupID, true, pInMsg->hdr.transSeqNum );
// 2813       }
// 2814 
// 2815       if ( sceneList != NULL )
// 2816         zcl_mem_free( sceneList );
// 2817 
// 2818       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2819       break;
// 2820 
// 2821 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 2822     case COMMAND_SCENE_COPY:
// 2823       {
// 2824         uint8 mode;
// 2825         uint16 groupIDFrom, groupIDTo;
// 2826         uint8 sceneIDFrom, sceneIDTo;
// 2827 
// 2828         pData = pInMsg->pData; // different payload format
// 2829 
// 2830         mode = *pData++;
// 2831         groupIDFrom = BUILD_UINT16( pData[0], pData[1] ); // from group ID
// 2832         pData += 2;
// 2833         sceneIDFrom = *pData++; // from scene ID
// 2834         groupIDTo = BUILD_UINT16( pData[0], pData[1] ); // to group ID
// 2835         pData += 2;
// 2836         if ( (mode & SCENE_COPY_MODE_ALL_BIT) == 0 )
// 2837         {
// 2838           sceneIDTo = *pData++; // to scene ID
// 2839         }
// 2840 
// 2841         // Make sure the groups exist
// 2842         if ( ( aps_FindGroup( pInMsg->msg->endPoint, groupIDFrom ) != NULL ) &&
// 2843              ( aps_FindGroup( pInMsg->msg->endPoint, groupIDTo ) != NULL ) )
// 2844         {
// 2845           // Allocate space for the scene list
// 2846           sceneList = zcl_mem_alloc( (mode & SCENE_COPY_MODE_ALL_BIT) ? ZCL_GEN_MAX_SCENES : 1 );
// 2847           if ( sceneList == NULL )
// 2848           {
// 2849             status = ZCL_STATUS_INSUFFICIENT_SPACE; // Couldn't allocate space for the scene list!
// 2850           }
// 2851           else
// 2852           {
// 2853             status = ZCL_STATUS_SUCCESS;
// 2854             if ( mode & SCENE_COPY_MODE_ALL_BIT ) // Copy all scenes
// 2855             {
// 2856               sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
// 2857                                                            groupIDFrom, sceneList );
// 2858             }
// 2859             else // Copy single scene
// 2860             {
// 2861               // Make sure the scene exists
// 2862               pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneIDFrom );
// 2863               if ( pScene != NULL )
// 2864               {
// 2865                 sceneList[0] = sceneIDFrom;
// 2866                 sceneCnt = 1;
// 2867               }
// 2868               else
// 2869               {
// 2870                 status = ZCL_STATUS_INVALID_FIELD; // Scene not found
// 2871               }
// 2872             }
// 2873           }
// 2874 
// 2875           if ( status == ZCL_STATUS_SUCCESS )
// 2876           {
// 2877             uint8 numScenesToAdd = 0;
// 2878             uint8 i;
// 2879             for ( i = 0; i < sceneCnt; i++ )
// 2880             {
// 2881               if ( zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, sceneList[i] ) == NULL )
// 2882               {
// 2883                 numScenesToAdd++;
// 2884               }
// 2885             }
// 2886             if ( zclGeneral_ScenesRemaingCapacity() >= numScenesToAdd )
// 2887             {
// 2888               // Copy the scenes
// 2889               for ( i = 0; i < sceneCnt; i++ )
// 2890               {
// 2891                 // Ignore scene ID from and scene ID to fields
// 2892                 pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDFrom, sceneList[i] );
// 2893                 if ( pScene != NULL )
// 2894                 {
// 2895                   zclGeneral_Scene_t *pToScene;
// 2896                   scene = *pScene;
// 2897                   scene.groupID = groupIDTo;
// 2898                   scene.ID = ( (mode & SCENE_COPY_MODE_ALL_BIT) ? sceneList[i] : sceneIDTo );
// 2899 
// 2900                   pToScene = zclGeneral_FindScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
// 2901                   if( pToScene != NULL )
// 2902                   {
// 2903                     zclGeneral_RemoveScene( pInMsg->msg->endPoint, groupIDTo, scene.ID );
// 2904                   }
// 2905                   // Add the scene
// 2906                   zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
// 2907                 }
// 2908               }
// 2909             }
// 2910             else
// 2911             {
// 2912               status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
// 2913             }
// 2914           }
// 2915         }
// 2916         else
// 2917         {
// 2918           status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
// 2919         }
// 2920 
// 2921         if ( UNICAST_MSG( pInMsg->msg ) )
// 2922         {
// 2923           if ( pScene == NULL )
// 2924           {
// 2925             pScene = &scene;
// 2926           }
// 2927           // Addressed to this device (not to a group) - send a response back
// 2928           zclGeneral_SendSceneCopyResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 2929                                             status, pScene->groupID, pScene->ID,
// 2930                                             true, pInMsg->hdr.transSeqNum );
// 2931         }
// 2932 
// 2933         if ( sceneList != NULL )
// 2934         {
// 2935           zcl_mem_free( sceneList );
// 2936         }
// 2937       }
// 2938 
// 2939       stat = ZCL_STATUS_CMD_HAS_RSP;
// 2940       break;
// 2941 #endif // ZCL_LIGHT_LINK_ENHANCE
// 2942 
// 2943     default:
// 2944       stat = ZFailure;
// 2945     break;
// 2946   }
// 2947 
// 2948   return ( stat );
// 2949 }
// 2950 
// 2951 /*********************************************************************
// 2952  * @fn      zclGeneral_ProcessInScenesClient
// 2953  *
// 2954  * @brief   Process in the received Scenes Command.
// 2955  *
// 2956  * @param   pInMsg - pointer to the incoming message
// 2957  *
// 2958  * @return  ZStatus_t
// 2959  */
// 2960 static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
// 2961                                                    zclGeneral_AppCallbacks_t *pCBs )
// 2962 {
// 2963   zclGeneral_Scene_t scene;
// 2964   uint8 *pData = pInMsg->pData;
// 2965   uint8 nameLen;
// 2966   zclSceneRsp_t rsp;
// 2967   uint8 i;
// 2968   ZStatus_t stat = ZSuccess;
// 2969 
// 2970   zcl_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
// 2971   zcl_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
// 2972 
// 2973   // Get the status field first
// 2974   rsp.status = *pData++;
// 2975 
// 2976   if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
// 2977   {
// 2978     rsp.capacity = *pData++;
// 2979   }
// 2980 
// 2981   scene.groupID = BUILD_UINT16( pData[0], pData[1] );
// 2982   pData += 2;   // Move past group ID
// 2983 
// 2984   switch ( pInMsg->hdr.commandID )
// 2985   {
// 2986     case COMMAND_SCENE_VIEW_RSP:
// 2987       // Parse the rest of the incoming message
// 2988       scene.ID = *pData++; // Not applicable to Remove All Response command
// 2989       scene.transTime = BUILD_UINT16( pData[0], pData[1] );
// 2990       pData += 2;
// 2991       nameLen = *pData++; // Name length
// 2992       if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
// 2993         nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
// 2994 
// 2995       scene.name[0] = nameLen;
// 2996       zcl_memcpy( &(scene.name[1]), pData, nameLen );
// 2997 
// 2998       pData += nameLen; // move past name, use original length
// 2999 
// 3000       //*** Do something with the extension field(s)
// 3001 
// 3002       // Fall through to callback - break is left off intentionally
// 3003 
// 3004     case COMMAND_SCENE_ADD_RSP:
// 3005     case COMMAND_SCENE_REMOVE_RSP:
// 3006     case COMMAND_SCENE_REMOVE_ALL_RSP:
// 3007     case COMMAND_SCENE_STORE_RSP:
// 3008       if ( pCBs->pfnSceneRsp )
// 3009       {
// 3010         if ( pInMsg->hdr.commandID != COMMAND_SCENE_REMOVE_ALL_RSP )
// 3011         {
// 3012           scene.ID = *pData++;
// 3013         }
// 3014         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3015         rsp.cmdID = pInMsg->hdr.commandID;
// 3016         rsp.scene = &scene;
// 3017 
// 3018         pCBs->pfnSceneRsp( &rsp );
// 3019       }
// 3020       break;
// 3021 
// 3022     case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
// 3023       {
// 3024         uint8 *sceneList = NULL;
// 3025 
// 3026         if ( rsp.status == ZCL_STATUS_SUCCESS )
// 3027         {
// 3028           uint8 sceneCnt = *pData++;
// 3029 
// 3030           if ( sceneCnt > 0 )
// 3031           {
// 3032             // Allocate space for the scene list
// 3033             sceneList = zcl_mem_alloc( sceneCnt );
// 3034             if ( sceneList != NULL )
// 3035             {
// 3036               rsp.sceneCnt = sceneCnt;
// 3037               for ( i = 0; i < sceneCnt; i++ )
// 3038                 sceneList[i] = *pData++;
// 3039             }
// 3040           }
// 3041         }
// 3042 
// 3043         if ( pCBs->pfnSceneRsp )
// 3044         {
// 3045           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3046           rsp.cmdID = pInMsg->hdr.commandID;
// 3047           rsp.sceneList = sceneList;
// 3048           rsp.scene = &scene;
// 3049 
// 3050           pCBs->pfnSceneRsp( &rsp);
// 3051         }
// 3052 
// 3053         if ( sceneList != NULL )
// 3054         {
// 3055           zcl_mem_free( sceneList );
// 3056         }
// 3057       }
// 3058       break;
// 3059 
// 3060     default:
// 3061       stat = ZFailure;
// 3062       break;
// 3063   }
// 3064 
// 3065   return ( stat );
// 3066 }
// 3067 #endif // ZCL_SCENES
// 3068 
// 3069 #ifdef ZCL_ON_OFF
// 3070 /*********************************************************************
// 3071  * @fn      zclGeneral_ProcessInCmdOnOff
// 3072  *
// 3073  * @brief   Process in the received On/Off Command.
// 3074  *
// 3075  * @param   pInMsg - pointer to the incoming message
// 3076  *
// 3077  * @return  ZStatus_t
// 3078  */
// 3079 static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
// 3080                                             zclGeneral_AppCallbacks_t *pCBs )
// 3081 {
// 3082   ZStatus_t stat = ZSuccess;
// 3083 
// 3084   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 3085   {
// 3086     switch ( pInMsg->hdr.commandID )
// 3087     {
// 3088       case COMMAND_OFF:
// 3089         //HAL_TURN_OFF_LED1(); //update 9/12/2016
// 3090         break;
// 3091       case COMMAND_ON:
// 3092         //HAL_TURN_ON_LED1();  //update 9/12/2016
// 3093         break;
// 3094       case COMMAND_TOGGLE:
// 3095         if ( pCBs->pfnOnOff )
// 3096         {
// 3097           pCBs->pfnOnOff( pInMsg->hdr.commandID );
// 3098         }
// 3099         break;
// 3100 
// 3101 #ifdef ZCL_LIGHT_LINK_ENHANCE
// 3102       case COMMAND_OFF_WITH_EFFECT:
// 3103         if ( pCBs->pfnOnOff_OffWithEffect )
// 3104         {
// 3105           zclOffWithEffect_t cmd;
// 3106 
// 3107           cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3108           cmd.effectId = pInMsg->pData[0];
// 3109           cmd.effectVariant = pInMsg->pData[1];
// 3110 
// 3111           pCBs->pfnOnOff_OffWithEffect( &cmd );
// 3112         }
// 3113         break;
// 3114 
// 3115       case COMMAND_ON_WITH_RECALL_GLOBAL_SCENE:
// 3116         if ( pCBs->pfnOnOff_OnWithRecallGlobalScene )
// 3117         {
// 3118           pCBs->pfnOnOff_OnWithRecallGlobalScene();
// 3119         }
// 3120         break;
// 3121 
// 3122       case COMMAND_ON_WITH_TIMED_OFF:
// 3123         if ( pCBs->pfnOnOff_OnWithTimedOff )
// 3124         {
// 3125           zclOnWithTimedOff_t cmd;
// 3126 
// 3127           cmd.onOffCtrl.byte = pInMsg->pData[0];
// 3128           cmd.onTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 3129           cmd.offWaitTime = BUILD_UINT16( pInMsg->pData[3], pInMsg->pData[4] );
// 3130           pCBs->pfnOnOff_OnWithTimedOff( &cmd );
// 3131         }
// 3132         break;
// 3133 #endif // ZCL_LIGHT_LINK_ENHANCE
// 3134 
// 3135       default:
// 3136         stat = ZFailure;
// 3137         break;
// 3138     }
// 3139   }
// 3140   // no Client command
// 3141 
// 3142   return ( stat );
// 3143 }
// 3144 #endif // ZCL_ON_OFF
// 3145 
// 3146 #ifdef ZCL_LEVEL_CTRL
// 3147 /*********************************************************************
// 3148  * @fn      zclGeneral_ProcessInLevelControl
// 3149  *
// 3150  * @brief   Process in the received Level Control Command.
// 3151  *
// 3152  * @param   pInMsg - pointer to the incoming message
// 3153  *
// 3154  * @return  ZStatus_t
// 3155  */
// 3156 static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
// 3157                                                    zclGeneral_AppCallbacks_t *pCBs )
// 3158 {
// 3159   uint8 withOnOff = FALSE;
// 3160   ZStatus_t stat = ZSuccess;
// 3161 
// 3162   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 3163   {
// 3164     switch ( pInMsg->hdr.commandID )
// 3165     {
// 3166       case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
// 3167         withOnOff = TRUE;
// 3168         // fall through
// 3169       case COMMAND_LEVEL_MOVE_TO_LEVEL:
// 3170         if ( pCBs->pfnLevelControlMoveToLevel )
// 3171         {
// 3172           zclLCMoveToLevel_t cmd;
// 3173 
// 3174           cmd.level = pInMsg->pData[0];
// 3175 
// 3176           if ( ( cmd.level >= ATTR_LEVEL_MIN_LEVEL ) &&
// 3177                ( cmd.level <= ATTR_LEVEL_MAX_LEVEL ) )
// 3178           {
// 3179             cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
// 3180             cmd.withOnOff = withOnOff;
// 3181 
// 3182             pCBs->pfnLevelControlMoveToLevel( &cmd );
// 3183           }
// 3184           else
// 3185           {
// 3186             // level range requested is invalid
// 3187             stat = ZCL_STATUS_INVALID_VALUE;
// 3188           }
// 3189         }
// 3190         break;
// 3191 
// 3192       case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
// 3193         withOnOff = TRUE;
// 3194         // fall through
// 3195       case COMMAND_LEVEL_MOVE:
// 3196         if ( pCBs->pfnLevelControlMove )
// 3197         {
// 3198           zclLCMove_t cmd;
// 3199 
// 3200           cmd.moveMode = pInMsg->pData[0];
// 3201           cmd.rate = pInMsg->pData[1];
// 3202           cmd.withOnOff = withOnOff;
// 3203 
// 3204           pCBs->pfnLevelControlMove( &cmd );
// 3205         }
// 3206         break;
// 3207 
// 3208       case COMMAND_LEVEL_STEP_WITH_ON_OFF:
// 3209         withOnOff = TRUE;
// 3210         // fall through
// 3211       case COMMAND_LEVEL_STEP:
// 3212         if ( pCBs->pfnLevelControlStep )
// 3213         {
// 3214           zclLCStep_t cmd;
// 3215 
// 3216           cmd.stepMode = pInMsg->pData[0];
// 3217           cmd.amount =  pInMsg->pData[1];
// 3218           cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
// 3219           cmd.withOnOff = withOnOff;
// 3220 
// 3221           pCBs->pfnLevelControlStep( &cmd );
// 3222         }
// 3223         break;
// 3224 
// 3225       case COMMAND_LEVEL_STOP:
// 3226       case COMMAND_LEVEL_STOP_WITH_ON_OFF:
// 3227         // Both Stop commands are identical
// 3228         if ( pCBs->pfnLevelControlStop )
// 3229         {
// 3230           pCBs->pfnLevelControlStop();
// 3231         }
// 3232         break;
// 3233 
// 3234       default:
// 3235         stat = ZFailure;
// 3236         break;
// 3237     }
// 3238   }
// 3239   // no Client command
// 3240 
// 3241   return ( stat );
// 3242 }
// 3243 #endif // ZCL_LEVEL_CTRL
// 3244 
// 3245 #ifdef ZCL_ALARMS
// 3246 /*********************************************************************
// 3247  * @fn      zclGeneral_AddAlarm
// 3248  *
// 3249  * @brief   Add an alarm for a cluster
// 3250  *
// 3251  * @param   endpoint -
// 3252  * @param   alarm - new alarm item
// 3253  *
// 3254  * @return  ZStatus_t
// 3255  */
// 3256 ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
// 3257 {
// 3258   zclGenAlarmItem_t *pNewItem;
// 3259   zclGenAlarmItem_t *pLoop;
// 3260 
// 3261   // Fill in the new profile list
// 3262   pNewItem = zcl_mem_alloc( sizeof( zclGenAlarmItem_t ) );
// 3263   if ( pNewItem == NULL )
// 3264     return ( ZMemError );
// 3265 
// 3266   // Fill in the plugin record.
// 3267   pNewItem->next = (zclGenAlarmItem_t *)NULL;
// 3268   pNewItem->endpoint =  endpoint;
// 3269   zcl_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
// 3270 
// 3271   // Find spot in list
// 3272   if (  zclGenAlarmTable == NULL )
// 3273   {
// 3274     zclGenAlarmTable = pNewItem;
// 3275   }
// 3276   else
// 3277   {
// 3278     // Look for end of list
// 3279     pLoop = zclGenAlarmTable;
// 3280     while ( pLoop->next != NULL )
// 3281       pLoop = pLoop->next;
// 3282 
// 3283     // Put new item at end of list
// 3284     pLoop->next = pNewItem;
// 3285   }
// 3286 
// 3287   return ( ZSuccess );
// 3288 }
// 3289 
// 3290 /*********************************************************************
// 3291  * @fn      zclGeneral_FindAlarm
// 3292  *
// 3293  * @brief   Find an alarm with alarmCode and clusterID
// 3294  *
// 3295  * @param   endpoint -
// 3296  * @param   groupID - what group the scene belongs to
// 3297  * @param   sceneID - ID to look for scene
// 3298  *
// 3299  * @return  a pointer to the alarm information, NULL if not found
// 3300  */
// 3301 zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 3302 {
// 3303   zclGenAlarmItem_t *pLoop;
// 3304 
// 3305   // Look for the alarm
// 3306   pLoop = zclGenAlarmTable;
// 3307   while ( pLoop )
// 3308   {
// 3309     if ( pLoop->endpoint == endpoint &&
// 3310          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 3311     {
// 3312       return ( &(pLoop->alarm) );
// 3313     }
// 3314     pLoop = pLoop->next;
// 3315   }
// 3316 
// 3317   return ( (zclGeneral_Alarm_t *)NULL );
// 3318 }
// 3319 
// 3320 /*********************************************************************
// 3321  * @fn      zclGeneral_FindEarliestAlarm
// 3322  *
// 3323  * @brief   Find an alarm with the earliest timestamp
// 3324  *
// 3325  * @param   endpoint -
// 3326  *
// 3327  * @return  a pointer to the alarm information, NULL if not found
// 3328  */
// 3329 zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
// 3330 {
// 3331   zclGenAlarmItem_t *pLoop;
// 3332   zclGenAlarmItem_t earliestAlarm;
// 3333   zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
// 3334 
// 3335   pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
// 3336 
// 3337   // Look for alarm with earliest time
// 3338   pLoop = zclGenAlarmTable;
// 3339   while ( pLoop )
// 3340   {
// 3341     if ( pLoop->endpoint == endpoint &&
// 3342          pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
// 3343     {
// 3344       pEarliestAlarm = pLoop;
// 3345     }
// 3346     pLoop = pLoop->next;
// 3347   }
// 3348 
// 3349   if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
// 3350     return ( &(pEarliestAlarm->alarm) );
// 3351 
// 3352   // No alarm
// 3353   return ( (zclGeneral_Alarm_t *)NULL );
// 3354 }
// 3355 
// 3356 /*********************************************************************
// 3357  * @fn      zclGeneral_ResetAlarm
// 3358  *
// 3359  * @brief   Remove an alarm with alarmCode and clusterID
// 3360  *
// 3361  * @param   endpoint -
// 3362  * @param   alarmCode -
// 3363  * @param   clusterID -
// 3364  *
// 3365  * @return  TRUE if removed, FALSE if not found
// 3366  */
// 3367 void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
// 3368 {
// 3369   zclGenAlarmItem_t *pLoop;
// 3370   zclGenAlarmItem_t *pPrev;
// 3371 
// 3372   // Look for end of list
// 3373   pLoop = zclGenAlarmTable;
// 3374   pPrev = NULL;
// 3375   while ( pLoop )
// 3376   {
// 3377     if ( pLoop->endpoint == endpoint &&
// 3378          pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
// 3379     {
// 3380       if ( pPrev == NULL )
// 3381         zclGenAlarmTable = pLoop->next;
// 3382       else
// 3383         pPrev->next = pLoop->next;
// 3384 
// 3385       // Free the memory
// 3386       zcl_mem_free( pLoop );
// 3387 
// 3388       // Notify the Application so that if the alarm condition still active then
// 3389       // a new notification will be generated, and a new alarm record will be
// 3390       // added to the alarm log
// 3391       // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
// 3392       return;
// 3393     }
// 3394     pPrev = pLoop;
// 3395     pLoop = pLoop->next;
// 3396   }
// 3397 }
// 3398 
// 3399 /*********************************************************************
// 3400  * @fn      zclGeneral_ResetAllAlarms
// 3401  *
// 3402  * @brief   Remove all alarms with endpoint
// 3403  *
// 3404  * @param   endpoint -
// 3405  * @param   notifyApp -
// 3406  *
// 3407  * @return  none
// 3408  */
// 3409 void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
// 3410 {
// 3411   zclGenAlarmItem_t *pLoop;
// 3412   zclGenAlarmItem_t *pPrev;
// 3413   zclGenAlarmItem_t *pNext;
// 3414 
// 3415   // Look for end of list
// 3416   pLoop = zclGenAlarmTable;
// 3417   pPrev = NULL;
// 3418   while ( pLoop )
// 3419   {
// 3420     if (  pLoop->endpoint == endpoint )
// 3421     {
// 3422       if ( pPrev == NULL )
// 3423         zclGenAlarmTable = pLoop->next;
// 3424       else
// 3425         pPrev->next = pLoop->next;
// 3426 
// 3427       pNext = pLoop->next;
// 3428 
// 3429       // Free the memory
// 3430       zcl_mem_free( pLoop );
// 3431 
// 3432       pLoop = pNext;
// 3433     }
// 3434     else
// 3435     {
// 3436       pPrev = pLoop;
// 3437       pLoop = pLoop->next;
// 3438     }
// 3439   }
// 3440 
// 3441   if ( notifyApp )
// 3442   {
// 3443     // Notify the Application so that if any alarm conditions still active then
// 3444     // a new notification will be generated, and a new alarm record will be
// 3445     // added to the alarm log
// 3446     // zclGeneral_NotifyResetAll(); // callback function?
// 3447   }
// 3448 }
// 3449 
// 3450 /*********************************************************************
// 3451  * @fn      zclGeneral_ProcessInAlarmsServer
// 3452  *
// 3453  * @brief   Process in the received Alarms Command.
// 3454  *
// 3455  * @param   pInMsg - pointer to the incoming message
// 3456  *
// 3457  * @return  ZStatus_t
// 3458  */
// 3459 static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
// 3460                                                    zclGeneral_AppCallbacks_t *pCBs )
// 3461 {
// 3462   zclAlarm_t alarm;
// 3463   zclGeneral_Alarm_t *pAlarm;
// 3464   uint8 *pData = pInMsg->pData;
// 3465   ZStatus_t stat = ZSuccess;
// 3466 
// 3467   switch ( pInMsg->hdr.commandID )
// 3468   {
// 3469     case COMMAND_ALARMS_RESET:
// 3470       if ( pCBs->pfnAlarm )
// 3471       {
// 3472         alarm.cmdID = pInMsg->hdr.commandID;
// 3473         alarm.alarmCode = pData[0];
// 3474         alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
// 3475 
// 3476         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3477       }
// 3478       else
// 3479       {
// 3480         stat = ZCL_STATUS_FAILURE;
// 3481       }
// 3482       break;
// 3483 
// 3484     case COMMAND_ALARMS_RESET_ALL:
// 3485       if ( pCBs->pfnAlarm )
// 3486       {
// 3487         alarm.cmdID = pInMsg->hdr.commandID;
// 3488 
// 3489         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3490       }
// 3491       else
// 3492       {
// 3493         stat = ZCL_STATUS_FAILURE;
// 3494       }
// 3495       break;
// 3496 
// 3497     case COMMAND_ALARMS_GET:
// 3498       if ( pCBs->pfnAlarm )
// 3499       {
// 3500         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 3501         alarm.cmdID = pInMsg->hdr.commandID;
// 3502 
// 3503         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3504 
// 3505         pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
// 3506         if ( pAlarm )
// 3507         {
// 3508           // Send a response back
// 3509           zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 3510                                            ZCL_STATUS_SUCCESS, pAlarm->code,
// 3511                                            pAlarm->clusterID, pAlarm->timeStamp,
// 3512                                            true, pInMsg->hdr.transSeqNum );
// 3513           // Remove the entry from the Alarm table
// 3514           zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
// 3515         }
// 3516         else
// 3517         {
// 3518           // Send a response back
// 3519           zclGeneral_SendAlarmGetResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
// 3520                                            ZCL_STATUS_NOT_FOUND, 0, 0, 0,
// 3521                                            true, pInMsg->hdr.transSeqNum );
// 3522         }
// 3523         stat = ZCL_STATUS_CMD_HAS_RSP;
// 3524       }
// 3525       else
// 3526       {
// 3527         stat = ZCL_STATUS_FAILURE;
// 3528       }
// 3529       break;
// 3530 
// 3531     case COMMAND_ALARMS_RESET_LOG:
// 3532       if ( pCBs->pfnAlarm )
// 3533       {
// 3534         alarm.cmdID = pInMsg->hdr.commandID;
// 3535 
// 3536         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3537 
// 3538         zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
// 3539       }
// 3540       else
// 3541       {
// 3542         stat = ZCL_STATUS_FAILURE;
// 3543       }
// 3544       break;
// 3545 
// 3546 #ifdef SE_UK_EXT
// 3547     case COMMAND_ALARMS_PUBLISH_EVENT_LOG:
// 3548       if ( pCBs->pfnPublishEventLog )
// 3549       {
// 3550         zclPublishEventLog_t eventLog;
// 3551 
// 3552         eventLog.logID = *pData++;
// 3553         eventLog.cmdIndex = *pData++;
// 3554         eventLog.totalCmds = *pData++;
// 3555 
// 3556         // First try to find out number of Sub Log Payloads
// 3557         eventLog.numSubLogs = (pInMsg->pDataLen-3)/(1+4); // event ID + event time
// 3558         if ( eventLog.numSubLogs > 0 )
// 3559         {
// 3560           // Try to alloc space for Log Payload
// 3561           eventLog.pLogs = (zclEventLogPayload_t *)zcl_mem_alloc( sizeof( zclEventLogPayload_t ) *
// 3562                                                                    eventLog.numSubLogs );
// 3563           if ( eventLog.pLogs != NULL )
// 3564           {
// 3565             // Copy Log Payload
// 3566             for ( uint8 i = 0; i < eventLog.numSubLogs; i++ )
// 3567             {
// 3568               eventLog.pLogs[i].eventId = *pData++;
// 3569               eventLog.pLogs[i].eventTime = zcl_build_uint32( pData, 4 );
// 3570               pData += 4;
// 3571             }
// 3572           }
// 3573           else
// 3574           {
// 3575             stat = ZCL_STATUS_SOFTWARE_FAILURE;
// 3576           }
// 3577         }
// 3578         else
// 3579         {
// 3580           eventLog.pLogs = NULL;
// 3581         }
// 3582 
// 3583         if ( stat == ZSuccess )
// 3584         {
// 3585           pCBs->pfnPublishEventLog( &(pInMsg->msg->srcAddr), &eventLog );
// 3586         }
// 3587 
// 3588         if ( eventLog.pLogs != NULL )
// 3589         {
// 3590           zcl_mem_free( eventLog.pLogs );
// 3591         }
// 3592       }
// 3593       break;
// 3594 #endif // SE_UK_EXT
// 3595 
// 3596     default:
// 3597       stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
// 3598       break;
// 3599   }
// 3600 
// 3601   return ( stat );
// 3602 }
// 3603 
// 3604 /*********************************************************************
// 3605  * @fn      zclGeneral_ProcessInAlarmsClient
// 3606  *
// 3607  * @brief   Process in the received Alarms Command.
// 3608  *
// 3609  * @param   pInMsg - pointer to the incoming message
// 3610  *
// 3611  * @return  ZStatus_t
// 3612  */
// 3613 static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
// 3614                                                    zclGeneral_AppCallbacks_t *pCBs )
// 3615 {
// 3616   uint8 *pData = pInMsg->pData;
// 3617   zclAlarm_t alarm;
// 3618   ZStatus_t stat = ZSuccess;
// 3619 
// 3620   zcl_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
// 3621 
// 3622   switch ( pInMsg->hdr.commandID )
// 3623   {
// 3624     case COMMAND_ALARMS_ALARM:
// 3625       if ( pCBs->pfnAlarm )
// 3626       {
// 3627         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 3628         alarm.cmdID = pInMsg->hdr.commandID;
// 3629         alarm.alarmCode = pData[0];
// 3630         alarm.clusterID = BUILD_UINT16( pData[1], pData[2] );
// 3631 
// 3632         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3633       }
// 3634       else
// 3635       {
// 3636         stat = ZCL_STATUS_FAILURE;
// 3637       }
// 3638       break;
// 3639 
// 3640     case COMMAND_ALARMS_GET_RSP:
// 3641       if ( pCBs->pfnAlarm )
// 3642       {
// 3643         alarm.srcAddr = &(pInMsg->msg->srcAddr);
// 3644         alarm.cmdID = pInMsg->hdr.commandID;
// 3645         alarm.alarmCode = *pData++;
// 3646         alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
// 3647 
// 3648         pCBs->pfnAlarm( pInMsg->hdr.fc.direction, &alarm );
// 3649       }
// 3650       else
// 3651       {
// 3652         stat = ZCL_STATUS_FAILURE;
// 3653       }
// 3654       break;
// 3655 
// 3656 #ifdef SE_UK_EXT
// 3657     case COMMAND_ALARMS_GET_EVENT_LOG:
// 3658       if ( pCBs->pfnGetEventLog )
// 3659       {
// 3660         zclGetEventLog_t eventLog;
// 3661 
// 3662         eventLog.logID = *pData++;
// 3663         eventLog.startTime = zcl_build_uint32( pData, 4 );
// 3664         pData += 4;
// 3665         eventLog.endTime = zcl_build_uint32( pData, 4 );
// 3666         pData += 4;
// 3667         eventLog.numEvents = *pData;
// 3668 
// 3669         pCBs->pfnGetEventLog( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
// 3670                               &eventLog, pInMsg->hdr.transSeqNum );
// 3671       }
// 3672       break;
// 3673 #endif // SE_UK_EXT
// 3674 
// 3675     default:
// 3676       stat = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
// 3677       break;
// 3678   }
// 3679 
// 3680   return ( stat );
// 3681 }
// 3682 #endif // ZCL_ALARMS
// 3683 
// 3684 #ifdef ZCL_LOCATION
// 3685 /*********************************************************************
// 3686  * @fn      zclGeneral_ProcessInLocationServer
// 3687  *
// 3688  * @brief   Process in the received Location Command.
// 3689  *
// 3690  * @param   pInMsg - pointer to the incoming message
// 3691  *
// 3692  * @return  ZStatus_t
// 3693  */
// 3694 static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
// 3695                                                      zclGeneral_AppCallbacks_t *pCBs )
// 3696 {
// 3697   uint8 *pData = pInMsg->pData;
// 3698   zclLocation_t cmd;
// 3699   ZStatus_t stat = ZSuccess;
// 3700 
// 3701   zcl_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
// 3702 
// 3703   switch ( pInMsg->hdr.commandID )
// 3704   {
// 3705     case COMMAND_LOCATION_SET_ABSOLUTE:
// 3706       cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 3707       pData += 2;
// 3708       cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 3709       pData += 2;
// 3710       cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 3711       pData += 2;
// 3712       cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 3713       pData += 2;
// 3714       cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3715 
// 3716       if ( pCBs->pfnLocation )
// 3717       {
// 3718         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3719         cmd.cmdID = pInMsg->hdr.commandID;
// 3720 
// 3721         // Update the absolute location info
// 3722         pCBs->pfnLocation( &cmd );
// 3723       }
// 3724       break;
// 3725 
// 3726     case COMMAND_LOCATION_SET_DEV_CFG:
// 3727       cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
// 3728       pData += 2;
// 3729       cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3730       pData += 2;
// 3731       cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3732       pData += 2;
// 3733       cmd.un.devCfg.numMeasurements = *pData++;
// 3734       cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3735 
// 3736       if ( pCBs->pfnLocation )
// 3737       {
// 3738         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3739         cmd.cmdID = pInMsg->hdr.commandID;
// 3740 
// 3741         // Update the device configuration info
// 3742         pCBs->pfnLocation( &cmd );
// 3743       }
// 3744       break;
// 3745 
// 3746     case COMMAND_LOCATION_GET_DEV_CFG:
// 3747       cmd.un.ieeeAddr = pData;
// 3748 
// 3749       if ( pCBs->pfnLocation )
// 3750       {
// 3751         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3752         cmd.cmdID = pInMsg->hdr.commandID;
// 3753         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 3754 
// 3755         // Retreive the Device Configuration
// 3756         pCBs->pfnLocation( &cmd );
// 3757       }
// 3758       stat = ZCL_STATUS_CMD_HAS_RSP;
// 3759       break;
// 3760 
// 3761     case COMMAND_LOCATION_GET_DATA:
// 3762       cmd.un.loc.bitmap.locByte = *pData++;
// 3763       cmd.un.loc.numResponses = *pData++;
// 3764 
// 3765       if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
// 3766         zcl_memcpy( cmd.un.loc.targetAddr, pData, 8 );
// 3767 
// 3768       if ( pCBs->pfnLocation )
// 3769       {
// 3770         cmd.srcAddr = &(pInMsg->msg->srcAddr);
// 3771         cmd.cmdID = pInMsg->hdr.commandID;
// 3772         cmd.seqNum = pInMsg->hdr.transSeqNum;
// 3773 
// 3774         // Retreive the Location Data
// 3775         pCBs->pfnLocation( &cmd );
// 3776       }
// 3777       stat = ZCL_STATUS_CMD_HAS_RSP;
// 3778       break;
// 3779 
// 3780     default:
// 3781       stat = ZFailure;
// 3782       break;
// 3783   }
// 3784 
// 3785   return ( stat );
// 3786 }
// 3787 
// 3788 /*********************************************************************
// 3789  * @fn      zclGeneral_ProcessInLocationDataRsp
// 3790  *
// 3791  * @brief   Process in the received Location Command.
// 3792  *
// 3793  * @param   pInMsg - pointer to the incoming message
// 3794  *
// 3795  * @return  ZStatus_t
// 3796  */
// 3797 static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
// 3798                                                  zclGeneral_AppCallbacks_t *pCBs )
// 3799 {
// 3800   uint8 *pData = pInMsg->pData;
// 3801   zclLocationRsp_t rsp;
// 3802 
// 3803   zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 3804 
// 3805   if ( pCBs->pfnLocationRsp )
// 3806   {
// 3807     if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
// 3808       rsp.un.loc.status = *pData++;
// 3809 
// 3810     if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
// 3811          rsp.un.loc.status == ZCL_STATUS_SUCCESS )
// 3812     {
// 3813       rsp.un.loc.data.type = *pData++;
// 3814       rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
// 3815       pData += 2;
// 3816       rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
// 3817       pData += 2;
// 3818 
// 3819       if ( locationType2D( rsp.un.loc.data.type ) == 0 )
// 3820       {
// 3821         rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
// 3822         pData += 2;
// 3823       }
// 3824 
// 3825       if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 3826       {
// 3827         rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
// 3828         pData += 2;
// 3829         rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3830         pData += 2;
// 3831       }
// 3832 
// 3833       if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
// 3834       {
// 3835         if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
// 3836           rsp.un.loc.data.calcLoc.locationMethod = *pData++;
// 3837 
// 3838         rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
// 3839         rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
// 3840       }
// 3841     }
// 3842 
// 3843     rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3844     rsp.cmdID = pInMsg->hdr.commandID;
// 3845 
// 3846     // Notify the Application
// 3847     pCBs->pfnLocationRsp( &rsp );
// 3848   }
// 3849 }
// 3850 
// 3851 /*********************************************************************
// 3852  * @fn      zclGeneral_ProcessInLocationClient
// 3853  *
// 3854  * @brief   Process in the received Location Command.
// 3855  *
// 3856  * @param   pInMsg - pointer to the incoming message
// 3857  *
// 3858  * @return  ZStatus_t
// 3859  */
// 3860 static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
// 3861                                                      zclGeneral_AppCallbacks_t *pCBs )
// 3862 {
// 3863   uint8 *pData = pInMsg->pData;
// 3864   zclLocationRsp_t rsp;
// 3865   ZStatus_t stat = ZSuccess;
// 3866 
// 3867   zcl_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
// 3868 
// 3869   switch ( pInMsg->hdr.commandID )
// 3870   {
// 3871     case COMMAND_LOCATION_DEV_CFG_RSP:
// 3872       if ( pCBs->pfnLocationRsp )
// 3873       {
// 3874         rsp.un.devCfg.status = *pData++;
// 3875         if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
// 3876         {
// 3877           rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
// 3878           pData += 2;
// 3879           rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
// 3880           pData += 2;
// 3881           rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3882           pData += 2;
// 3883           rsp.un.devCfg.data.numMeasurements = *pData++;
// 3884           rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
// 3885 
// 3886           rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3887           rsp.cmdID = pInMsg->hdr.commandID;
// 3888 
// 3889           // Notify the Application
// 3890           pCBs->pfnLocationRsp( &rsp );
// 3891         }
// 3892       }
// 3893       break;
// 3894 
// 3895     case COMMAND_LOCATION_DATA_RSP:
// 3896     case COMMAND_LOCATION_DATA_NOTIF:
// 3897     case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
// 3898       zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
// 3899       break;
// 3900 
// 3901     case COMMAND_LOCATION_RSSI_PING:
// 3902       if ( pCBs->pfnLocationRsp )
// 3903       {
// 3904         rsp.un.locationType = *pData;
// 3905 
// 3906         rsp.srcAddr = &(pInMsg->msg->srcAddr);
// 3907         rsp.cmdID = pInMsg->hdr.commandID;
// 3908 
// 3909         // Notify the Application
// 3910         pCBs->pfnLocationRsp( &rsp );
// 3911       }
// 3912       break;
// 3913 
// 3914     default:
// 3915       stat = ZFailure;
// 3916       break;
// 3917   }
// 3918 
// 3919   return ( stat );
// 3920 }
// 3921 #endif // ZCL_LOCATION
// 3922 
// 3923 #ifdef ZCL_SCENES
// 3924 #if !defined ( ZCL_STANDALONE )
// 3925 /*********************************************************************
// 3926  * @fn      zclGeneral_ScenesInitNV
// 3927  *
// 3928  * @brief   Initialize the NV Scene Table Items
// 3929  *
// 3930  * @param   none
// 3931  *
// 3932  * @return  number of scenes
// 3933  */
// 3934 static uint8 zclGeneral_ScenesInitNV( void )
// 3935 {
// 3936   uint8  status;
// 3937   uint16 size;
// 3938 
// 3939   size = (uint16)((sizeof ( nvGenScenesHdr_t ))
// 3940                   + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
// 3941 
// 3942   status = zcl_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
// 3943 
// 3944   if ( status != ZSUCCESS )
// 3945   {
// 3946     zclGeneral_ScenesSetDefaultNV();
// 3947   }
// 3948 
// 3949   return status;
// 3950 }
// 3951 #endif // ZCL_STANDALONE
// 3952 
// 3953 #if !defined ( ZCL_STANDALONE )
// 3954 /*********************************************************************
// 3955  * @fn          zclGeneral_ScenesSetDefaultNV
// 3956  *
// 3957  * @brief       Write the defaults to NV
// 3958  *
// 3959  * @param       none
// 3960  *
// 3961  * @return      none
// 3962  */
// 3963 static void zclGeneral_ScenesSetDefaultNV( void )
// 3964 {
// 3965   nvGenScenesHdr_t hdr;
// 3966 
// 3967   // Initialize the header
// 3968   hdr.numRecs = 0;
// 3969 
// 3970   // Save off the header
// 3971   zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 3972 }
// 3973 #endif // ZCL_STANDALONE
// 3974 
// 3975 #if !defined ( ZCL_STANDALONE )
// 3976 /*********************************************************************
// 3977  * @fn          zclGeneral_ScenesWriteNV
// 3978  *
// 3979  * @brief       Save the Scene Table in NV
// 3980  *
// 3981  * @param       none
// 3982  *
// 3983  * @return      none
// 3984  */
// 3985 static void zclGeneral_ScenesWriteNV( void )
// 3986 {
// 3987   nvGenScenesHdr_t hdr;
// 3988   zclGenSceneItem_t *pLoop;
// 3989   zclGenSceneNVItem_t item;
// 3990 
// 3991   hdr.numRecs = 0;
// 3992 
// 3993   // Look for end of list
// 3994   pLoop = zclGenSceneTable;
// 3995   while ( pLoop )
// 3996   {
// 3997     // Build the record
// 3998     item.endpoint = pLoop->endpoint;
// 3999     zcl_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
// 4000 
// 4001     // Save the record to NV
// 4002     zcl_nv_write( ZCD_NV_SCENE_TABLE,
// 4003             (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
// 4004                     sizeof ( zclGenSceneNVItem_t ), &item );
// 4005 
// 4006     hdr.numRecs++;
// 4007 
// 4008     pLoop = pLoop->next;
// 4009   }
// 4010 
// 4011   // Save off the header
// 4012   zcl_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
// 4013 }
// 4014 #endif // ZCL_STANDALONE
// 4015 
// 4016 #if !defined ( ZCL_STANDALONE )
// 4017 /*********************************************************************
// 4018  * @fn          zclGeneral_ScenesRestoreFromNV
// 4019  *
// 4020  * @brief       Restore the Scene table from NV
// 4021  *
// 4022  * @param       none
// 4023  *
// 4024  * @return      Number of entries restored
// 4025  */
// 4026 static uint16 zclGeneral_ScenesRestoreFromNV( void )
// 4027 {
// 4028   uint16 x;
// 4029   nvGenScenesHdr_t hdr;
// 4030 
// 4031   zclGenSceneNVItem_t item;
// 4032   uint16 numAdded = 0;
// 4033 
// 4034   if ( zcl_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
// 4035   {
// 4036     // Read in the device list
// 4037     for ( x = 0; x < hdr.numRecs; x++ )
// 4038     {
// 4039       if ( zcl_nv_read( ZCD_NV_SCENE_TABLE,
// 4040                 (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
// 4041                                   sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
// 4042       {
// 4043         // Add the scene
// 4044         if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
// 4045         {
// 4046           numAdded++;
// 4047         }
// 4048       }
// 4049     }
// 4050   }
// 4051 
// 4052   return ( numAdded );
// 4053 }
// 4054 #endif // ZCL_STANDALONE
// 4055 
// 4056 #if !defined ( ZCL_STANDALONE )
// 4057 /*********************************************************************
// 4058  * @fn          zclGeneral_ScenesInit
// 4059  *
// 4060  * @brief       Initialize the scenes table
// 4061  *
// 4062  * @param       none
// 4063  *
// 4064  * @return      none
// 4065  */
// 4066 void zclGeneral_ScenesInit( void )
// 4067 {
// 4068   // Initialize NV items
// 4069   zclGeneral_ScenesInitNV();
// 4070 
// 4071   // Restore the Scene table
// 4072   zclGeneral_ScenesRestoreFromNV();
// 4073 }
// 4074 #endif // ZCL_STANDALONE
// 4075 
// 4076 #if !defined ( ZCL_STANDALONE )
// 4077 /*********************************************************************
// 4078  * @fn          zclGeneral_ScenesSave
// 4079  *
// 4080  * @brief       Save the scenes table
// 4081  *
// 4082  * @param       none
// 4083  *
// 4084  * @return      none
// 4085  */
// 4086 void zclGeneral_ScenesSave( void )
// 4087 {
// 4088   // Update NV
// 4089   zclGeneral_ScenesWriteNV();
// 4090 }
// 4091 #endif // ZCL_STANDALONE
// 4092 
// 4093 #endif // ZCL_SCENES
// 4094 
// 4095 /***************************************************************************
// 4096 ****************************************************************************/
// 
// 424 bytes in segment BANKED_CODE
//  18 bytes in segment BANK_RELAYS
//   3 bytes in segment XDATA_Z
// 
//  18 bytes of CODE     memory
// 424 bytes of HUGECODE memory
//   3 bytes of XDATA    memory
//
//Errors: none
//Warnings: none
